// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/duckdb_dart.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class DuckDbDartBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DuckDbDartBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DuckDbDartBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// For historical reasons; programs expect signal's return value to be
  /// defined by <sys/signal.h>.
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait1(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait1(
      arg0,
    );
  }

  late final _wait1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait1 =
      _wait1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    int arg0,
    int arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, id_t, ffi.Pointer<siginfo_t>, ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int arg0,
  ) {
    return _alloca(
      arg0,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int arg0,
  ) {
    return _valloc(
      arg0,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  /// calloc is now declared in _malloc.h
  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  /// free is now declared in _malloc.h
  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  /// malloc is now declared in _malloc.h
  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  /// posix_memalign is now declared in _malloc.h
  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  /// realloc is now declared in _malloc.h
  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int arg2,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _initstate(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int arg1,
  ) {
    return _arc4random_addrandom(
      arg0,
      arg1,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  /// getcap(3) functions
  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int arg1,
  ) {
    return _getloadavg(
      arg0,
      arg1,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// getsubopt(3) external variable
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  /// !
  /// Creates a new database or opens an existing database file stored at the given path.
  /// If no path is given a new in-memory database is created instead.
  /// The instantiated database should be closed with 'duckdb_close'
  ///
  /// path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
  /// out_database: The result database object.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_open(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<duckdb_database> out_database,
  ) {
    return _duckdb_open(
      path,
      out_database,
    );
  }

  late final _duckdb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_database>)>>('duckdb_open');
  late final _duckdb_open = _duckdb_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_database>)>();

  /// !
  /// Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.
  ///
  /// path: Path to the database file on disk, or `nullptr` or `:memory:` to open an in-memory database.
  /// out_database: The result database object.
  /// config: (Optional) configuration used to start up the database system.
  /// out_error: If set and the function returns DuckDBError, this will contain the reason why the start-up failed.
  /// Note that the error must be freed using `duckdb_free`.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_open_ext(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<duckdb_database> out_database,
    duckdb_config config,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_error,
  ) {
    return _duckdb_open_ext(
      path,
      out_database,
      config,
      out_error,
    );
  }

  late final _duckdb_open_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_database>,
              duckdb_config,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('duckdb_open_ext');
  late final _duckdb_open_ext = _duckdb_open_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_database>,
          duckdb_config, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// !
  /// Closes the specified database and de-allocates all memory allocated for that database.
  /// This should be called after you are done with any database allocated through `duckdb_open`.
  /// Note that failing to call `duckdb_close` (in case of e.g. a program crash) will not cause data corruption.
  /// Still it is recommended to always correctly close a database object after you are done with it.
  ///
  /// database: The database object to shut down.
  void duckdb_close(
    ffi.Pointer<duckdb_database> database,
  ) {
    return _duckdb_close(
      database,
    );
  }

  late final _duckdb_closePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_database>)>>(
      'duckdb_close');
  late final _duckdb_close = _duckdb_closePtr
      .asFunction<void Function(ffi.Pointer<duckdb_database>)>();

  /// !
  /// Opens a connection to a database. Connections are required to query the database, and store transactional state
  /// associated with the connection.
  /// The instantiated connection should be closed using 'duckdb_disconnect'
  ///
  /// database: The database file to connect to.
  /// out_connection: The result connection object.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_connect(
    duckdb_database database,
    ffi.Pointer<duckdb_connection> out_connection,
  ) {
    return _duckdb_connect(
      database,
      out_connection,
    );
  }

  late final _duckdb_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_database,
              ffi.Pointer<duckdb_connection>)>>('duckdb_connect');
  late final _duckdb_connect = _duckdb_connectPtr.asFunction<
      int Function(duckdb_database, ffi.Pointer<duckdb_connection>)>();

  /// !
  /// Interrupt running query
  ///
  /// connection: The connection to interruot
  void duckdb_interrupt(
    duckdb_connection connection,
  ) {
    return _duckdb_interrupt(
      connection,
    );
  }

  late final _duckdb_interruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_connection)>>(
          'duckdb_interrupt');
  late final _duckdb_interrupt =
      _duckdb_interruptPtr.asFunction<void Function(duckdb_connection)>();

  /// !
  /// Get progress of the running query
  ///
  /// connection: The working connection
  /// returns: -1 if no progress or a percentage of the progress
  double duckdb_query_progress(
    duckdb_connection connection,
  ) {
    return _duckdb_query_progress(
      connection,
    );
  }

  late final _duckdb_query_progressPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_connection)>>(
          'duckdb_query_progress');
  late final _duckdb_query_progress = _duckdb_query_progressPtr
      .asFunction<double Function(duckdb_connection)>();

  /// !
  /// Closes the specified connection and de-allocates all memory allocated for that connection.
  ///
  /// connection: The connection to close.
  void duckdb_disconnect(
    ffi.Pointer<duckdb_connection> connection,
  ) {
    return _duckdb_disconnect(
      connection,
    );
  }

  late final _duckdb_disconnectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<duckdb_connection>)>>('duckdb_disconnect');
  late final _duckdb_disconnect = _duckdb_disconnectPtr
      .asFunction<void Function(ffi.Pointer<duckdb_connection>)>();

  /// !
  /// Returns the version of the linked DuckDB, with a version postfix for dev versions
  ///
  /// Usually used for developing C extensions that must return this for a compatibility check.
  ffi.Pointer<ffi.Char> duckdb_library_version() {
    return _duckdb_library_version();
  }

  late final _duckdb_library_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'duckdb_library_version');
  late final _duckdb_library_version =
      _duckdb_library_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// ===--------------------------------------------------------------------===//
  /// Configuration
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Initializes an empty configuration object that can be used to provide start-up options for the DuckDB instance
  /// through `duckdb_open_ext`.
  ///
  /// This will always succeed unless there is a malloc failure.
  ///
  /// * out_config: The result configuration object.
  /// * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  /// */
  int duckdb_create_config(
    ffi.Pointer<duckdb_config> out_config,
  ) {
    return _duckdb_create_config(
      out_config,
    );
  }

  late final _duckdb_create_configPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<duckdb_config>)>>(
      'duckdb_create_config');
  late final _duckdb_create_config = _duckdb_create_configPtr
      .asFunction<int Function(ffi.Pointer<duckdb_config>)>();

  /// !
  /// This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.
  ///
  /// This should not be called in a loop as it internally loops over all the options.
  ///
  /// returns: The amount of config options available.
  int duckdb_config_count() {
    return _duckdb_config_count();
  }

  late final _duckdb_config_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('duckdb_config_count');
  late final _duckdb_config_count =
      _duckdb_config_countPtr.asFunction<int Function()>();

  /// !
  /// Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.
  /// display configuration options. This will succeed unless `index` is out of range (i.e. `>= duckdb_config_count`).
  ///
  /// The result name or description MUST NOT be freed.
  ///
  /// index: The index of the configuration option (between 0 and `duckdb_config_count`)
  /// out_name: A name of the configuration flag.
  /// out_description: A description of the configuration flag.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_get_config_flag(
    int index,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_name,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_description,
  ) {
    return _duckdb_get_config_flag(
      index,
      out_name,
      out_description,
    );
  }

  late final _duckdb_get_config_flagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Size, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('duckdb_get_config_flag');
  late final _duckdb_get_config_flag = _duckdb_get_config_flagPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// !
  /// Sets the specified option for the specified configuration. The configuration option is indicated by name.
  /// To obtain a list of config options, see `duckdb_get_config_flag`.
  ///
  /// In the source code, configuration options are defined in `config.cpp`.
  ///
  /// This can fail if either the name is invalid, or if the value provided for the option is invalid.
  ///
  /// duckdb_config: The configuration object to set the option on.
  /// name: The name of the configuration flag to set.
  /// option: The value to set the configuration flag to.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_set_config(
    duckdb_config config,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> option,
  ) {
    return _duckdb_set_config(
      config,
      name,
      option,
    );
  }

  late final _duckdb_set_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_config, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('duckdb_set_config');
  late final _duckdb_set_config = _duckdb_set_configPtr.asFunction<
      int Function(
          duckdb_config, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Destroys the specified configuration option and de-allocates all memory allocated for the object.
  ///
  /// config: The configuration object to destroy.
  void duckdb_destroy_config(
    ffi.Pointer<duckdb_config> config,
  ) {
    return _duckdb_destroy_config(
      config,
    );
  }

  late final _duckdb_destroy_configPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_config>)>>(
      'duckdb_destroy_config');
  late final _duckdb_destroy_config = _duckdb_destroy_configPtr
      .asFunction<void Function(ffi.Pointer<duckdb_config>)>();

  /// ===--------------------------------------------------------------------===//
  /// Query Execution
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Executes a SQL query within a connection and stores the full (materialized) result in the out_result pointer.
  /// If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
  /// `duckdb_result_error`.
  ///
  /// Note that after running `duckdb_query`, `duckdb_destroy_result` must be called on the result object even if the
  /// query fails, otherwise the error stored within the result will not be freed correctly.
  ///
  /// * connection: The connection to perform the query in.
  /// * query: The SQL query to run.
  /// * out_result: The query result.
  /// * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  /// */
  int duckdb_query(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return _duckdb_query(
      connection,
      query,
      out_result,
    );
  }

  late final _duckdb_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_result>)>>('duckdb_query');
  late final _duckdb_query = _duckdb_queryPtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<duckdb_result>)>();

  /// !
  /// Closes the result and de-allocates all memory allocated for that connection.
  ///
  /// result: The result to destroy.
  void duckdb_destroy_result(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_destroy_result(
      result,
    );
  }

  late final _duckdb_destroy_resultPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_result>)>>(
      'duckdb_destroy_result');
  late final _duckdb_destroy_result = _duckdb_destroy_resultPtr
      .asFunction<void Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns the column name of the specified column. The result should not need be freed; the column names will
  /// automatically be destroyed when the result is destroyed.
  ///
  /// Returns `NULL` if the column is out of range.
  ///
  /// result: The result object to fetch the column name from.
  /// col: The column index.
  /// returns: The column name of the specified column.
  ffi.Pointer<ffi.Char> duckdb_column_name(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_name(
      result,
      col,
    );
  }

  late final _duckdb_column_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_column_name');
  late final _duckdb_column_name = _duckdb_column_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the column type of the specified column.
  ///
  /// Returns `DUCKDB_TYPE_INVALID` if the column is out of range.
  ///
  /// result: The result object to fetch the column type from.
  /// col: The column index.
  /// returns: The column type of the specified column.
  int duckdb_column_type(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_type(
      result,
      col,
    );
  }

  late final _duckdb_column_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_column_type');
  late final _duckdb_column_type = _duckdb_column_typePtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the logical column type of the specified column.
  ///
  /// The return type of this call should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// Returns `NULL` if the column is out of range.
  ///
  /// result: The result object to fetch the column type from.
  /// col: The column index.
  /// returns: The logical column type of the specified column.
  duckdb_logical_type duckdb_column_logical_type(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_logical_type(
      result,
      col,
    );
  }

  late final _duckdb_column_logical_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_result>,
              idx_t)>>('duckdb_column_logical_type');
  late final _duckdb_column_logical_type =
      _duckdb_column_logical_typePtr.asFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the number of columns present in a the result object.
  ///
  /// result: The result object.
  /// returns: The number of columns present in the result object.
  int duckdb_column_count(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_column_count(
      result,
    );
  }

  late final _duckdb_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(ffi.Pointer<duckdb_result>)>>(
          'duckdb_column_count');
  late final _duckdb_column_count = _duckdb_column_countPtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns the number of rows present in a the result object.
  ///
  /// result: The result object.
  /// returns: The number of rows present in the result object.
  int duckdb_row_count(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_row_count(
      result,
    );
  }

  late final _duckdb_row_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(ffi.Pointer<duckdb_result>)>>(
          'duckdb_row_count');
  late final _duckdb_row_count = _duckdb_row_countPtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns the number of rows changed by the query stored in the result. This is relevant only for INSERT/UPDATE/DELETE
  /// queries. For other queries the rows_changed will be 0.
  ///
  /// result: The result object.
  /// returns: The number of rows changed.
  int duckdb_rows_changed(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_rows_changed(
      result,
    );
  }

  late final _duckdb_rows_changedPtr =
      _lookup<ffi.NativeFunction<idx_t Function(ffi.Pointer<duckdb_result>)>>(
          'duckdb_rows_changed');
  late final _duckdb_rows_changed = _duckdb_rows_changedPtr
      .asFunction<int Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
  ///
  /// Returns the data of a specific column of a result in columnar format.
  ///
  /// The function returns a dense array which contains the result data. The exact type stored in the array depends on the
  /// corresponding duckdb_type (as provided by `duckdb_column_type`). For the exact type by which the data should be
  /// accessed, see the comments in [the types section](types) or the `DUCKDB_TYPE` enum.
  ///
  /// For example, for a column of type `DUCKDB_TYPE_INTEGER`, rows can be accessed in the following manner:
  /// ```c
  /// int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
  /// printf("Data for row %d: %d\n", row, data[row]);
  /// ```
  ///
  /// result: The result object to fetch the column data from.
  /// col: The column index.
  /// returns: The column data of the specified column.
  ffi.Pointer<ffi.Void> duckdb_column_data(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_column_data(
      result,
      col,
    );
  }

  late final _duckdb_column_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_column_data');
  late final _duckdb_column_data = _duckdb_column_dataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.
  ///
  /// Returns the nullmask of a specific column of a result in columnar format. The nullmask indicates for every row
  /// whether or not the corresponding row is `NULL`. If a row is `NULL`, the values present in the array provided
  /// by `duckdb_column_data` are undefined.
  ///
  /// ```c
  /// int32_t *data = (int32_t *) duckdb_column_data(&result, 0);
  /// bool *nullmask = duckdb_nullmask_data(&result, 0);
  /// if (nullmask[row]) {
  /// printf("Data for row %d: NULL\n", row);
  /// } else {
  /// printf("Data for row %d: %d\n", row, data[row]);
  /// }
  /// ```
  ///
  /// result: The result object to fetch the nullmask from.
  /// col: The column index.
  /// returns: The nullmask of the specified column.
  ffi.Pointer<ffi.Bool> duckdb_nullmask_data(
    ffi.Pointer<duckdb_result> result,
    int col,
  ) {
    return _duckdb_nullmask_data(
      result,
      col,
    );
  }

  late final _duckdb_nullmask_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Bool> Function(
              ffi.Pointer<duckdb_result>, idx_t)>>('duckdb_nullmask_data');
  late final _duckdb_nullmask_data = _duckdb_nullmask_dataPtr.asFunction<
      ffi.Pointer<ffi.Bool> Function(ffi.Pointer<duckdb_result>, int)>();

  /// !
  /// Returns the error message contained within the result. The error is only set if `duckdb_query` returns `DuckDBError`.
  ///
  /// The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_result` is called.
  ///
  /// result: The result object to fetch the error from.
  /// returns: The error of the result.
  ffi.Pointer<ffi.Char> duckdb_result_error(
    ffi.Pointer<duckdb_result> result,
  ) {
    return _duckdb_result_error(
      result,
    );
  }

  late final _duckdb_result_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_result>)>>('duckdb_result_error');
  late final _duckdb_result_error = _duckdb_result_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>)>();

  /// !
  /// Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.
  ///
  /// The result must be destroyed with `duckdb_destroy_data_chunk`.
  ///
  /// This function supersedes all `duckdb_value` functions, as well as the `duckdb_column_data` and `duckdb_nullmask_data`
  /// functions. It results in significantly better performance, and should be preferred in newer code-bases.
  ///
  /// If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
  /// mixed with the legacy result functions).
  ///
  /// Use `duckdb_result_chunk_count` to figure out how many chunks there are in the result.
  ///
  /// result: The result object to fetch the data chunk from.
  /// chunk_index: The chunk index to fetch from.
  /// returns: The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.
  duckdb_data_chunk duckdb_result_get_chunk(
    duckdb_result result,
    int chunk_index,
  ) {
    return _duckdb_result_get_chunk(
      result,
      chunk_index,
    );
  }

  late final _duckdb_result_get_chunkPtr = _lookup<
          ffi.NativeFunction<duckdb_data_chunk Function(duckdb_result, idx_t)>>(
      'duckdb_result_get_chunk');
  late final _duckdb_result_get_chunk = _duckdb_result_get_chunkPtr
      .asFunction<duckdb_data_chunk Function(duckdb_result, int)>();

  /// !
  /// Checks if the type of the internal result is StreamQueryResult.
  ///
  /// result: The result object to check.
  /// returns: Whether or not the result object is of the type StreamQueryResult
  bool duckdb_result_is_streaming(
    duckdb_result result,
  ) {
    return _duckdb_result_is_streaming(
      result,
    );
  }

  late final _duckdb_result_is_streamingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_result)>>(
          'duckdb_result_is_streaming');
  late final _duckdb_result_is_streaming =
      _duckdb_result_is_streamingPtr.asFunction<bool Function(duckdb_result)>();

  /// !
  /// Returns the number of data chunks present in the result.
  ///
  /// result: The result object
  /// returns: Number of data chunks present in the result.
  int duckdb_result_chunk_count(
    duckdb_result result,
  ) {
    return _duckdb_result_chunk_count(
      result,
    );
  }

  late final _duckdb_result_chunk_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_result)>>(
          'duckdb_result_chunk_count');
  late final _duckdb_result_chunk_count =
      _duckdb_result_chunk_countPtr.asFunction<int Function(duckdb_result)>();

  /// !
  /// returns: The boolean value at the specified location, or false if the value cannot be converted.
  bool duckdb_value_boolean(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_boolean(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_booleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_boolean');
  late final _duckdb_value_boolean = _duckdb_value_booleanPtr
      .asFunction<bool Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The int8_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int8(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int8(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int8 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int8');
  late final _duckdb_value_int8 = _duckdb_value_int8Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The int16_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int16(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int16(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int16 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int16');
  late final _duckdb_value_int16 = _duckdb_value_int16Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The int32_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int32(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int32(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int32');
  late final _duckdb_value_int32 = _duckdb_value_int32Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The int64_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_int64(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_int64(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_int64');
  late final _duckdb_value_int64 = _duckdb_value_int64Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.
  duckdb_hugeint duckdb_value_hugeint(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_hugeint(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_hugeintPtr = _lookup<
      ffi.NativeFunction<
          duckdb_hugeint Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_hugeint');
  late final _duckdb_value_hugeint = _duckdb_value_hugeintPtr.asFunction<
      duckdb_hugeint Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.
  duckdb_decimal duckdb_value_decimal(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_decimal(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_decimalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_decimal Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_decimal');
  late final _duckdb_value_decimal = _duckdb_value_decimalPtr.asFunction<
      duckdb_decimal Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The uint8_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint8(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint8(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_uint8');
  late final _duckdb_value_uint8 = _duckdb_value_uint8Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The uint16_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint16(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint16(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint16 Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uint16');
  late final _duckdb_value_uint16 = _duckdb_value_uint16Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The uint32_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint32(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint32(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uint32');
  late final _duckdb_value_uint32 = _duckdb_value_uint32Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The uint64_t value at the specified location, or 0 if the value cannot be converted.
  int duckdb_value_uint64(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_uint64(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_uint64');
  late final _duckdb_value_uint64 = _duckdb_value_uint64Ptr
      .asFunction<int Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The float value at the specified location, or 0 if the value cannot be converted.
  double duckdb_value_float(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_float(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_float');
  late final _duckdb_value_float = _duckdb_value_floatPtr
      .asFunction<double Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The double value at the specified location, or 0 if the value cannot be converted.
  double duckdb_value_double(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_double(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_double');
  late final _duckdb_value_double = _duckdb_value_doublePtr
      .asFunction<double Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_date value at the specified location, or 0 if the value cannot be converted.
  duckdb_date duckdb_value_date(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_date(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_datePtr = _lookup<
      ffi.NativeFunction<
          duckdb_date Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_date');
  late final _duckdb_value_date = _duckdb_value_datePtr
      .asFunction<duckdb_date Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_time value at the specified location, or 0 if the value cannot be converted.
  duckdb_time duckdb_value_time(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_time(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_timePtr = _lookup<
      ffi.NativeFunction<
          duckdb_time Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_time');
  late final _duckdb_value_time = _duckdb_value_timePtr
      .asFunction<duckdb_time Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.
  duckdb_timestamp duckdb_value_timestamp(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_timestamp(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_timestampPtr = _lookup<
      ffi.NativeFunction<
          duckdb_timestamp Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_timestamp');
  late final _duckdb_value_timestamp = _duckdb_value_timestampPtr.asFunction<
      duckdb_timestamp Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_interval value at the specified location, or 0 if the value cannot be converted.
  duckdb_interval duckdb_value_interval(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_interval(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_intervalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_interval Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_interval');
  late final _duckdb_value_interval = _duckdb_value_intervalPtr.asFunction<
      duckdb_interval Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATED: use duckdb_value_string instead. This function does not work correctly if the string contains null bytes.
  /// returns: The text value at the specified location as a null-terminated string, or nullptr if the value cannot be
  /// converted. The result must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_value_varchar(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_varchar(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_varcharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_varchar');
  late final _duckdb_value_varchar = _duckdb_value_varcharPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !s
  /// returns: The string value at the specified location.
  /// The result must be freed with `duckdb_free`.
  duckdb_string duckdb_value_string(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_string(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_stringPtr = _lookup<
      ffi.NativeFunction<
          duckdb_string Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_string');
  late final _duckdb_value_string = _duckdb_value_stringPtr.asFunction<
      duckdb_string Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains
  /// null bytes.
  /// returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
  /// If the column is NOT a VARCHAR column this function will return NULL.
  ///
  /// The result must NOT be freed.
  ffi.Pointer<ffi.Char> duckdb_value_varchar_internal(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_varchar_internal(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_varchar_internalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_varchar_internal');
  late final _duckdb_value_varchar_internal =
      _duckdb_value_varchar_internalPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// DEPRECATED: use duckdb_value_string_internal instead. This function does not work correctly if the string contains
  /// null bytes.
  /// returns: The char* value at the specified location. ONLY works on VARCHAR columns and does not auto-cast.
  /// If the column is NOT a VARCHAR column this function will return NULL.
  ///
  /// The result must NOT be freed.
  duckdb_string duckdb_value_string_internal(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_string_internal(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_string_internalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_string Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_string_internal');
  late final _duckdb_value_string_internal =
      _duckdb_value_string_internalPtr.asFunction<
          duckdb_string Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the
  /// value cannot be converted. The resulting "blob.data" must be freed with `duckdb_free.`
  duckdb_blob duckdb_value_blob(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_blob(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_blobPtr = _lookup<
      ffi.NativeFunction<
          duckdb_blob Function(
              ffi.Pointer<duckdb_result>, idx_t, idx_t)>>('duckdb_value_blob');
  late final _duckdb_value_blob = _duckdb_value_blobPtr
      .asFunction<duckdb_blob Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// !
  /// returns: Returns true if the value at the specified index is NULL, and false otherwise.
  bool duckdb_value_is_null(
    ffi.Pointer<duckdb_result> result,
    int col,
    int row,
  ) {
    return _duckdb_value_is_null(
      result,
      col,
      row,
    );
  }

  late final _duckdb_value_is_nullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<duckdb_result>, idx_t,
              idx_t)>>('duckdb_value_is_null');
  late final _duckdb_value_is_null = _duckdb_value_is_nullPtr
      .asFunction<bool Function(ffi.Pointer<duckdb_result>, int, int)>();

  /// ===--------------------------------------------------------------------===//
  /// Helpers
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Allocate `size` bytes of memory using the duckdb internal malloc function. Any memory allocated in this manner
  /// should be freed using `duckdb_free`.
  ///
  /// * size: The number of bytes to allocate.
  /// * returns: A pointer to the allocated memory region.
  /// */
  ffi.Pointer<ffi.Void> duckdb_malloc(
    int size,
  ) {
    return _duckdb_malloc(
      size,
    );
  }

  late final _duckdb_mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'duckdb_malloc');
  late final _duckdb_malloc =
      _duckdb_mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// !
  /// Free a value returned from `duckdb_malloc`, `duckdb_value_varchar` or `duckdb_value_blob`.
  ///
  /// ptr: The memory region to de-allocate.
  void duckdb_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _duckdb_free(
      ptr,
    );
  }

  late final _duckdb_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'duckdb_free');
  late final _duckdb_free =
      _duckdb_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// !
  /// The internal vector size used by DuckDB.
  /// This is the amount of tuples that will fit into a data chunk created by `duckdb_create_data_chunk`.
  ///
  /// returns: The vector size.
  int duckdb_vector_size() {
    return _duckdb_vector_size();
  }

  late final _duckdb_vector_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function()>>('duckdb_vector_size');
  late final _duckdb_vector_size =
      _duckdb_vector_sizePtr.asFunction<int Function()>();

  /// !
  /// Whether or not the duckdb_string_t value is inlined.
  /// This means that the data of the string does not have a separate allocation.
  bool duckdb_string_is_inlined(
    duckdb_string_t string,
  ) {
    return _duckdb_string_is_inlined(
      string,
    );
  }

  late final _duckdb_string_is_inlinedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_string_t)>>(
          'duckdb_string_is_inlined');
  late final _duckdb_string_is_inlined =
      _duckdb_string_is_inlinedPtr.asFunction<bool Function(duckdb_string_t)>();

  /// ===--------------------------------------------------------------------===//
  /// Date/Time/Timestamp Helpers
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_date_struct`).
  ///
  /// * date: The date object, as obtained from a `DUCKDB_TYPE_DATE` column.
  /// * returns: The `duckdb_date_struct` with the decomposed elements.
  /// */
  duckdb_date_struct duckdb_from_date(
    duckdb_date date,
  ) {
    return _duckdb_from_date(
      date,
    );
  }

  late final _duckdb_from_datePtr =
      _lookup<ffi.NativeFunction<duckdb_date_struct Function(duckdb_date)>>(
          'duckdb_from_date');
  late final _duckdb_from_date = _duckdb_from_datePtr
      .asFunction<duckdb_date_struct Function(duckdb_date)>();

  /// !
  /// Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).
  ///
  /// date: The year, month and date stored in a `duckdb_date_struct`.
  /// returns: The `duckdb_date` element.
  duckdb_date duckdb_to_date(
    duckdb_date_struct date,
  ) {
    return _duckdb_to_date(
      date,
    );
  }

  late final _duckdb_to_datePtr =
      _lookup<ffi.NativeFunction<duckdb_date Function(duckdb_date_struct)>>(
          'duckdb_to_date');
  late final _duckdb_to_date =
      _duckdb_to_datePtr.asFunction<duckdb_date Function(duckdb_date_struct)>();

  /// !
  /// Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).
  ///
  /// time: The time object, as obtained from a `DUCKDB_TYPE_TIME` column.
  /// returns: The `duckdb_time_struct` with the decomposed elements.
  duckdb_time_struct duckdb_from_time(
    duckdb_time time,
  ) {
    return _duckdb_from_time(
      time,
    );
  }

  late final _duckdb_from_timePtr =
      _lookup<ffi.NativeFunction<duckdb_time_struct Function(duckdb_time)>>(
          'duckdb_from_time');
  late final _duckdb_from_time = _duckdb_from_timePtr
      .asFunction<duckdb_time_struct Function(duckdb_time)>();

  /// !
  /// Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).
  ///
  /// time: The hour, minute, second and microsecond in a `duckdb_time_struct`.
  /// returns: The `duckdb_time` element.
  duckdb_time duckdb_to_time(
    duckdb_time_struct time,
  ) {
    return _duckdb_to_time(
      time,
    );
  }

  late final _duckdb_to_timePtr =
      _lookup<ffi.NativeFunction<duckdb_time Function(duckdb_time_struct)>>(
          'duckdb_to_time');
  late final _duckdb_to_time =
      _duckdb_to_timePtr.asFunction<duckdb_time Function(duckdb_time_struct)>();

  /// !
  /// Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.
  ///
  /// ts: The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.
  /// returns: The `duckdb_timestamp_struct` with the decomposed elements.
  duckdb_timestamp_struct duckdb_from_timestamp(
    duckdb_timestamp ts,
  ) {
    return _duckdb_from_timestamp(
      ts,
    );
  }

  late final _duckdb_from_timestampPtr = _lookup<
      ffi.NativeFunction<
          duckdb_timestamp_struct Function(
              duckdb_timestamp)>>('duckdb_from_timestamp');
  late final _duckdb_from_timestamp = _duckdb_from_timestampPtr
      .asFunction<duckdb_timestamp_struct Function(duckdb_timestamp)>();

  /// !
  /// Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.
  ///
  /// ts: The de-composed elements in a `duckdb_timestamp_struct`.
  /// returns: The `duckdb_timestamp` element.
  duckdb_timestamp duckdb_to_timestamp(
    duckdb_timestamp_struct ts,
  ) {
    return _duckdb_to_timestamp(
      ts,
    );
  }

  late final _duckdb_to_timestampPtr = _lookup<
      ffi.NativeFunction<
          duckdb_timestamp Function(
              duckdb_timestamp_struct)>>('duckdb_to_timestamp');
  late final _duckdb_to_timestamp = _duckdb_to_timestampPtr
      .asFunction<duckdb_timestamp Function(duckdb_timestamp_struct)>();

  /// ===--------------------------------------------------------------------===//
  /// Hugeint Helpers
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` column) into a double.
  ///
  /// * val: The hugeint value.
  /// * returns: The converted `double` element.
  /// */
  double duckdb_hugeint_to_double(
    duckdb_hugeint val,
  ) {
    return _duckdb_hugeint_to_double(
      val,
    );
  }

  late final _duckdb_hugeint_to_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_hugeint)>>(
          'duckdb_hugeint_to_double');
  late final _duckdb_hugeint_to_double = _duckdb_hugeint_to_doublePtr
      .asFunction<double Function(duckdb_hugeint)>();

  /// !
  /// Converts a double value to a duckdb_hugeint object.
  ///
  /// If the conversion fails because the double value is too big the result will be 0.
  ///
  /// val: The double value.
  /// returns: The converted `duckdb_hugeint` element.
  duckdb_hugeint duckdb_double_to_hugeint(
    double val,
  ) {
    return _duckdb_double_to_hugeint(
      val,
    );
  }

  late final _duckdb_double_to_hugeintPtr =
      _lookup<ffi.NativeFunction<duckdb_hugeint Function(ffi.Double)>>(
          'duckdb_double_to_hugeint');
  late final _duckdb_double_to_hugeint = _duckdb_double_to_hugeintPtr
      .asFunction<duckdb_hugeint Function(double)>();

  /// !
  /// Converts a double value to a duckdb_decimal object.
  ///
  /// If the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.
  ///
  /// val: The double value.
  /// returns: The converted `duckdb_decimal` element.
  duckdb_decimal duckdb_double_to_decimal(
    double val,
    int width,
    int scale,
  ) {
    return _duckdb_double_to_decimal(
      val,
      width,
      scale,
    );
  }

  late final _duckdb_double_to_decimalPtr = _lookup<
      ffi.NativeFunction<
          duckdb_decimal Function(
              ffi.Double, ffi.Uint8, ffi.Uint8)>>('duckdb_double_to_decimal');
  late final _duckdb_double_to_decimal = _duckdb_double_to_decimalPtr
      .asFunction<duckdb_decimal Function(double, int, int)>();

  /// ===--------------------------------------------------------------------===//
  /// Decimal Helpers
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.
  ///
  /// * val: The decimal value.
  /// * returns: The converted `double` element.
  /// */
  double duckdb_decimal_to_double(
    duckdb_decimal val,
  ) {
    return _duckdb_decimal_to_double(
      val,
    );
  }

  late final _duckdb_decimal_to_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(duckdb_decimal)>>(
          'duckdb_decimal_to_double');
  late final _duckdb_decimal_to_double = _duckdb_decimal_to_doublePtr
      .asFunction<double Function(duckdb_decimal)>();

  /// !
  /// Create a prepared statement object from a query.
  ///
  /// Note that after calling `duckdb_prepare`, the prepared statement should always be destroyed using
  /// `duckdb_destroy_prepare`, even if the prepare fails.
  ///
  /// If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
  ///
  /// connection: The connection object
  /// query: The SQL query to prepare
  /// out_prepared_statement: The resulting prepared statement object
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_prepare(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_prepared_statement> out_prepared_statement,
  ) {
    return _duckdb_prepare(
      connection,
      query,
      out_prepared_statement,
    );
  }

  late final _duckdb_preparePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_prepared_statement>)>>('duckdb_prepare');
  late final _duckdb_prepare = _duckdb_preparePtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<duckdb_prepared_statement>)>();

  /// !
  /// Closes the prepared statement and de-allocates all memory allocated for the statement.
  ///
  /// prepared_statement: The prepared statement to destroy.
  void duckdb_destroy_prepare(
    ffi.Pointer<duckdb_prepared_statement> prepared_statement,
  ) {
    return _duckdb_destroy_prepare(
      prepared_statement,
    );
  }

  late final _duckdb_destroy_preparePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_prepared_statement>)>>(
      'duckdb_destroy_prepare');
  late final _duckdb_destroy_prepare = _duckdb_destroy_preparePtr
      .asFunction<void Function(ffi.Pointer<duckdb_prepared_statement>)>();

  /// !
  /// Returns the error message associated with the given prepared statement.
  /// If the prepared statement has no error message, this returns `nullptr` instead.
  ///
  /// The error message should not be freed. It will be de-allocated when `duckdb_destroy_prepare` is called.
  ///
  /// prepared_statement: The prepared statement to obtain the error from.
  /// returns: The error message, or `nullptr` if there is none.
  ffi.Pointer<ffi.Char> duckdb_prepare_error(
    duckdb_prepared_statement prepared_statement,
  ) {
    return _duckdb_prepare_error(
      prepared_statement,
    );
  }

  late final _duckdb_prepare_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_prepared_statement)>>('duckdb_prepare_error');
  late final _duckdb_prepare_error = _duckdb_prepare_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_prepared_statement)>();

  /// !
  /// Returns the number of parameters that can be provided to the given prepared statement.
  ///
  /// Returns 0 if the query was not successfully prepared.
  ///
  /// prepared_statement: The prepared statement to obtain the number of parameters for.
  int duckdb_nparams(
    duckdb_prepared_statement prepared_statement,
  ) {
    return _duckdb_nparams(
      prepared_statement,
    );
  }

  late final _duckdb_nparamsPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_prepared_statement)>>(
          'duckdb_nparams');
  late final _duckdb_nparams =
      _duckdb_nparamsPtr.asFunction<int Function(duckdb_prepared_statement)>();

  /// !
  /// Returns the name used to identify the parameter
  /// The returned string should be freed using `duckdb_free`.
  ///
  /// Returns NULL if the index is out of range for the provided prepared statement.
  ///
  /// prepared_statement: The prepared statement for which to get the parameter name from.
  ffi.Pointer<ffi.Char> duckdb_parameter_name(
    duckdb_prepared_statement prepared_statement,
    int index,
  ) {
    return _duckdb_parameter_name(
      prepared_statement,
      index,
    );
  }

  late final _duckdb_parameter_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_parameter_name');
  late final _duckdb_parameter_name = _duckdb_parameter_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(duckdb_prepared_statement, int)>();

  /// !
  /// Returns the parameter type for the parameter at the given index.
  ///
  /// Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the statement was not successfully prepared.
  ///
  /// prepared_statement: The prepared statement.
  /// param_idx: The parameter index.
  /// returns: The parameter type
  int duckdb_param_type(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
  ) {
    return _duckdb_param_type(
      prepared_statement,
      param_idx,
    );
  }

  late final _duckdb_param_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_param_type');
  late final _duckdb_param_type = _duckdb_param_typePtr
      .asFunction<int Function(duckdb_prepared_statement, int)>();

  /// !
  /// Clear the params bind to the prepared statement.
  int duckdb_clear_bindings(
    duckdb_prepared_statement prepared_statement,
  ) {
    return _duckdb_clear_bindings(
      prepared_statement,
    );
  }

  late final _duckdb_clear_bindingsPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_prepared_statement)>>(
      'duckdb_clear_bindings');
  late final _duckdb_clear_bindings = _duckdb_clear_bindingsPtr
      .asFunction<int Function(duckdb_prepared_statement)>();

  /// !
  /// Binds a value to the prepared statement at the specified index.
  int duckdb_bind_value(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_value val,
  ) {
    return _duckdb_bind_value(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_value)>>('duckdb_bind_value');
  late final _duckdb_bind_value = _duckdb_bind_valuePtr
      .asFunction<int Function(duckdb_prepared_statement, int, duckdb_value)>();

  /// !
  /// Retrieve the index of the parameter for the prepared statement, identified by name
  int duckdb_bind_parameter_index(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<idx_t> param_idx_out,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_bind_parameter_index(
      prepared_statement,
      param_idx_out,
      name,
    );
  }

  late final _duckdb_bind_parameter_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, ffi.Pointer<idx_t>,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_parameter_index');
  late final _duckdb_bind_parameter_index =
      _duckdb_bind_parameter_indexPtr.asFunction<
          int Function(duckdb_prepared_statement, ffi.Pointer<idx_t>,
              ffi.Pointer<ffi.Char>)>();

  /// !
  /// Binds a bool value to the prepared statement at the specified index.
  int duckdb_bind_boolean(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    bool val,
  ) {
    return _duckdb_bind_boolean(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_booleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Bool)>>('duckdb_bind_boolean');
  late final _duckdb_bind_boolean = _duckdb_bind_booleanPtr
      .asFunction<int Function(duckdb_prepared_statement, int, bool)>();

  /// !
  /// Binds an int8_t value to the prepared statement at the specified index.
  int duckdb_bind_int8(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_int8(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_int8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_prepared_statement, idx_t, ffi.Int8)>>('duckdb_bind_int8');
  late final _duckdb_bind_int8 = _duckdb_bind_int8Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an int16_t value to the prepared statement at the specified index.
  int duckdb_bind_int16(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_int16(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_int16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Int16)>>('duckdb_bind_int16');
  late final _duckdb_bind_int16 = _duckdb_bind_int16Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an int32_t value to the prepared statement at the specified index.
  int duckdb_bind_int32(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_int32(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Int32)>>('duckdb_bind_int32');
  late final _duckdb_bind_int32 = _duckdb_bind_int32Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an int64_t value to the prepared statement at the specified index.
  int duckdb_bind_int64(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_int64(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Int64)>>('duckdb_bind_int64');
  late final _duckdb_bind_int64 = _duckdb_bind_int64Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds a duckdb_hugeint value to the prepared statement at the specified index.
  int duckdb_bind_hugeint(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_hugeint val,
  ) {
    return _duckdb_bind_hugeint(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_hugeintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_hugeint)>>('duckdb_bind_hugeint');
  late final _duckdb_bind_hugeint = _duckdb_bind_hugeintPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_hugeint)>();

  /// !
  /// Binds a duckdb_decimal value to the prepared statement at the specified index.
  int duckdb_bind_decimal(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_decimal val,
  ) {
    return _duckdb_bind_decimal(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_decimalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_decimal)>>('duckdb_bind_decimal');
  late final _duckdb_bind_decimal = _duckdb_bind_decimalPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_decimal)>();

  /// !
  /// Binds an uint8_t value to the prepared statement at the specified index.
  int duckdb_bind_uint8(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_uint8(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_uint8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Uint8)>>('duckdb_bind_uint8');
  late final _duckdb_bind_uint8 = _duckdb_bind_uint8Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an uint16_t value to the prepared statement at the specified index.
  int duckdb_bind_uint16(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_uint16(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_uint16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Uint16)>>('duckdb_bind_uint16');
  late final _duckdb_bind_uint16 = _duckdb_bind_uint16Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an uint32_t value to the prepared statement at the specified index.
  int duckdb_bind_uint32(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_uint32(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Uint32)>>('duckdb_bind_uint32');
  late final _duckdb_bind_uint32 = _duckdb_bind_uint32Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds an uint64_t value to the prepared statement at the specified index.
  int duckdb_bind_uint64(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    int val,
  ) {
    return _duckdb_bind_uint64(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Uint64)>>('duckdb_bind_uint64');
  late final _duckdb_bind_uint64 = _duckdb_bind_uint64Ptr
      .asFunction<int Function(duckdb_prepared_statement, int, int)>();

  /// !
  /// Binds a float value to the prepared statement at the specified index.
  int duckdb_bind_float(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    double val,
  ) {
    return _duckdb_bind_float(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Float)>>('duckdb_bind_float');
  late final _duckdb_bind_float = _duckdb_bind_floatPtr
      .asFunction<int Function(duckdb_prepared_statement, int, double)>();

  /// !
  /// Binds a double value to the prepared statement at the specified index.
  int duckdb_bind_double(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    double val,
  ) {
    return _duckdb_bind_double(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Double)>>('duckdb_bind_double');
  late final _duckdb_bind_double = _duckdb_bind_doublePtr
      .asFunction<int Function(duckdb_prepared_statement, int, double)>();

  /// !
  /// Binds a duckdb_date value to the prepared statement at the specified index.
  int duckdb_bind_date(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_date val,
  ) {
    return _duckdb_bind_date(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_datePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_date)>>('duckdb_bind_date');
  late final _duckdb_bind_date = _duckdb_bind_datePtr
      .asFunction<int Function(duckdb_prepared_statement, int, duckdb_date)>();

  /// !
  /// Binds a duckdb_time value to the prepared statement at the specified index.
  int duckdb_bind_time(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_time val,
  ) {
    return _duckdb_bind_time(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_time)>>('duckdb_bind_time');
  late final _duckdb_bind_time = _duckdb_bind_timePtr
      .asFunction<int Function(duckdb_prepared_statement, int, duckdb_time)>();

  /// !
  /// Binds a duckdb_timestamp value to the prepared statement at the specified index.
  int duckdb_bind_timestamp(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_timestamp val,
  ) {
    return _duckdb_bind_timestamp(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_timestamp)>>('duckdb_bind_timestamp');
  late final _duckdb_bind_timestamp = _duckdb_bind_timestampPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_timestamp)>();

  /// !
  /// Binds a duckdb_interval value to the prepared statement at the specified index.
  int duckdb_bind_interval(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    duckdb_interval val,
  ) {
    return _duckdb_bind_interval(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_intervalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              duckdb_interval)>>('duckdb_bind_interval');
  late final _duckdb_bind_interval = _duckdb_bind_intervalPtr.asFunction<
      int Function(duckdb_prepared_statement, int, duckdb_interval)>();

  /// !
  /// Binds a null-terminated varchar value to the prepared statement at the specified index.
  int duckdb_bind_varchar(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    ffi.Pointer<ffi.Char> val,
  ) {
    return _duckdb_bind_varchar(
      prepared_statement,
      param_idx,
      val,
    );
  }

  late final _duckdb_bind_varcharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_varchar');
  late final _duckdb_bind_varchar = _duckdb_bind_varcharPtr.asFunction<
      int Function(duckdb_prepared_statement, int, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Binds a varchar value to the prepared statement at the specified index.
  int duckdb_bind_varchar_length(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    ffi.Pointer<ffi.Char> val,
    int length,
  ) {
    return _duckdb_bind_varchar_length(
      prepared_statement,
      param_idx,
      val,
      length,
    );
  }

  late final _duckdb_bind_varchar_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Pointer<ffi.Char>, idx_t)>>('duckdb_bind_varchar_length');
  late final _duckdb_bind_varchar_length =
      _duckdb_bind_varchar_lengthPtr.asFunction<
          int Function(
              duckdb_prepared_statement, int, ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Binds a blob value to the prepared statement at the specified index.
  int duckdb_bind_blob(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
    ffi.Pointer<ffi.Void> data,
    int length,
  ) {
    return _duckdb_bind_blob(
      prepared_statement,
      param_idx,
      data,
      length,
    );
  }

  late final _duckdb_bind_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement, idx_t,
              ffi.Pointer<ffi.Void>, idx_t)>>('duckdb_bind_blob');
  late final _duckdb_bind_blob = _duckdb_bind_blobPtr.asFunction<
      int Function(
          duckdb_prepared_statement, int, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// Binds a NULL value to the prepared statement at the specified index.
  int duckdb_bind_null(
    duckdb_prepared_statement prepared_statement,
    int param_idx,
  ) {
    return _duckdb_bind_null(
      prepared_statement,
      param_idx,
    );
  }

  late final _duckdb_bind_nullPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_prepared_statement, idx_t)>>('duckdb_bind_null');
  late final _duckdb_bind_null = _duckdb_bind_nullPtr
      .asFunction<int Function(duckdb_prepared_statement, int)>();

  /// !
  /// Executes the prepared statement with the given bound parameters, and returns a materialized query result.
  ///
  /// This method can be called multiple times for each prepared statement, and the parameters can be modified
  /// between calls to this function.
  ///
  /// prepared_statement: The prepared statement to execute.
  /// out_result: The query result.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_execute_prepared(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return _duckdb_execute_prepared(
      prepared_statement,
      out_result,
    );
  }

  late final _duckdb_execute_preparedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement,
              ffi.Pointer<duckdb_result>)>>('duckdb_execute_prepared');
  late final _duckdb_execute_prepared = _duckdb_execute_preparedPtr.asFunction<
      int Function(duckdb_prepared_statement, ffi.Pointer<duckdb_result>)>();

  /// !
  /// Executes the prepared statement with the given bound parameters, and returns an arrow query result.
  ///
  /// prepared_statement: The prepared statement to execute.
  /// out_result: The query result.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_execute_prepared_arrow(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_arrow> out_result,
  ) {
    return _duckdb_execute_prepared_arrow(
      prepared_statement,
      out_result,
    );
  }

  late final _duckdb_execute_prepared_arrowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement,
              ffi.Pointer<duckdb_arrow>)>>('duckdb_execute_prepared_arrow');
  late final _duckdb_execute_prepared_arrow =
      _duckdb_execute_prepared_arrowPtr.asFunction<
          int Function(duckdb_prepared_statement, ffi.Pointer<duckdb_arrow>)>();

  /// !
  /// Scans the Arrow stream and creates a view with the given name.
  ///
  /// connection: The connection on which to execute the scan.
  /// table_name: Name of the temporary view to create.
  /// arrow: Arrow stream wrapper.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_arrow_scan(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> table_name,
    duckdb_arrow_stream arrow,
  ) {
    return _duckdb_arrow_scan(
      connection,
      table_name,
      arrow,
    );
  }

  late final _duckdb_arrow_scanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              duckdb_arrow_stream)>>('duckdb_arrow_scan');
  late final _duckdb_arrow_scan = _duckdb_arrow_scanPtr.asFunction<
      int Function(
          duckdb_connection, ffi.Pointer<ffi.Char>, duckdb_arrow_stream)>();

  /// !
  /// Scans the Arrow array and creates a view with the given name.
  ///
  /// connection: The connection on which to execute the scan.
  /// table_name: Name of the temporary view to create.
  /// arrow_schema: Arrow schema wrapper.
  /// arrow_array: Arrow array wrapper.
  /// out_stream: Output array stream that wraps around the passed schema, for releasing/deleting once done.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_arrow_array_scan(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> table_name,
    duckdb_arrow_schema arrow_schema,
    duckdb_arrow_array arrow_array,
    ffi.Pointer<duckdb_arrow_stream> out_stream,
  ) {
    return _duckdb_arrow_array_scan(
      connection,
      table_name,
      arrow_schema,
      arrow_array,
      out_stream,
    );
  }

  late final _duckdb_arrow_array_scanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              duckdb_arrow_schema,
              duckdb_arrow_array,
              ffi.Pointer<duckdb_arrow_stream>)>>('duckdb_arrow_array_scan');
  late final _duckdb_arrow_array_scan = _duckdb_arrow_array_scanPtr.asFunction<
      int Function(
          duckdb_connection,
          ffi.Pointer<ffi.Char>,
          duckdb_arrow_schema,
          duckdb_arrow_array,
          ffi.Pointer<duckdb_arrow_stream>)>();

  /// !
  /// Extract all statements from a query.
  /// Note that after calling `duckdb_extract_statements`, the extracted statements should always be destroyed using
  /// `duckdb_destroy_extracted`, even if no statements were extracted.
  /// If the extract fails, `duckdb_extract_statements_error` can be called to obtain the reason why the extract failed.
  /// connection: The connection object
  /// query: The SQL query to extract
  /// out_extracted_statements: The resulting extracted statements object
  /// returns: The number of extracted statements or 0 on failure.
  int duckdb_extract_statements(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_extracted_statements> out_extracted_statements,
  ) {
    return _duckdb_extract_statements(
      connection,
      query,
      out_extracted_statements,
    );
  }

  late final _duckdb_extract_statementsPtr = _lookup<
          ffi.NativeFunction<
              idx_t Function(duckdb_connection, ffi.Pointer<ffi.Char>,
                  ffi.Pointer<duckdb_extracted_statements>)>>(
      'duckdb_extract_statements');
  late final _duckdb_extract_statements =
      _duckdb_extract_statementsPtr.asFunction<
          int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_extracted_statements>)>();

  /// !
  /// Prepare an extracted statement.
  /// Note that after calling `duckdb_prepare_extracted_statement`, the prepared statement should always be destroyed using
  /// `duckdb_destroy_prepare`, even if the prepare fails.
  /// If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason why the prepare failed.
  /// connection: The connection object
  /// extracted_statements: The extracted statements object
  /// index: The index of the extracted statement to prepare
  /// out_prepared_statement: The resulting prepared statement object
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_prepare_extracted_statement(
    duckdb_connection connection,
    duckdb_extracted_statements extracted_statements,
    int index,
    ffi.Pointer<duckdb_prepared_statement> out_prepared_statement,
  ) {
    return _duckdb_prepare_extracted_statement(
      connection,
      extracted_statements,
      index,
      out_prepared_statement,
    );
  }

  late final _duckdb_prepare_extracted_statementPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(duckdb_connection, duckdb_extracted_statements,
                  idx_t, ffi.Pointer<duckdb_prepared_statement>)>>(
      'duckdb_prepare_extracted_statement');
  late final _duckdb_prepare_extracted_statement =
      _duckdb_prepare_extracted_statementPtr.asFunction<
          int Function(duckdb_connection, duckdb_extracted_statements, int,
              ffi.Pointer<duckdb_prepared_statement>)>();

  /// !
  /// Returns the error message contained within the extracted statements.
  /// The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_extracted` is called.
  /// result: The extracted statements to fetch the error from.
  /// returns: The error of the extracted statements.
  ffi.Pointer<ffi.Char> duckdb_extract_statements_error(
    duckdb_extracted_statements extracted_statements,
  ) {
    return _duckdb_extract_statements_error(
      extracted_statements,
    );
  }

  late final _duckdb_extract_statements_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_extracted_statements)>>('duckdb_extract_statements_error');
  late final _duckdb_extract_statements_error =
      _duckdb_extract_statements_errorPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(duckdb_extracted_statements)>();

  /// !
  /// De-allocates all memory allocated for the extracted statements.
  /// extracted_statements: The extracted statements to destroy.
  void duckdb_destroy_extracted(
    ffi.Pointer<duckdb_extracted_statements> extracted_statements,
  ) {
    return _duckdb_destroy_extracted(
      extracted_statements,
    );
  }

  late final _duckdb_destroy_extractedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_extracted_statements>)>>(
      'duckdb_destroy_extracted');
  late final _duckdb_destroy_extracted = _duckdb_destroy_extractedPtr
      .asFunction<void Function(ffi.Pointer<duckdb_extracted_statements>)>();

  /// ===--------------------------------------------------------------------===//
  /// Pending Result Interface
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Executes the prepared statement with the given bound parameters, and returns a pending result.
  /// The pending result represents an intermediate structure for a query that is not yet fully executed.
  /// The pending result can be used to incrementally execute a query, returning control to the client between tasks.
  ///
  /// Note that after calling `duckdb_pending_prepared`, the pending result should always be destroyed using
  /// `duckdb_destroy_pending`, even if this function returns DuckDBError.
  ///
  /// * prepared_statement: The prepared statement to execute.
  /// * out_result: The pending query result.
  /// * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  /// */
  int duckdb_pending_prepared(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_pending_result> out_result,
  ) {
    return _duckdb_pending_prepared(
      prepared_statement,
      out_result,
    );
  }

  late final _duckdb_pending_preparedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_prepared_statement,
              ffi.Pointer<duckdb_pending_result>)>>('duckdb_pending_prepared');
  late final _duckdb_pending_prepared = _duckdb_pending_preparedPtr.asFunction<
      int Function(
          duckdb_prepared_statement, ffi.Pointer<duckdb_pending_result>)>();

  /// !
  /// Executes the prepared statement with the given bound parameters, and returns a pending result.
  /// This pending result will create a streaming duckdb_result when executed.
  /// The pending result represents an intermediate structure for a query that is not yet fully executed.
  ///
  /// Note that after calling `duckdb_pending_prepared_streaming`, the pending result should always be destroyed using
  /// `duckdb_destroy_pending`, even if this function returns DuckDBError.
  ///
  /// prepared_statement: The prepared statement to execute.
  /// out_result: The pending query result.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_pending_prepared_streaming(
    duckdb_prepared_statement prepared_statement,
    ffi.Pointer<duckdb_pending_result> out_result,
  ) {
    return _duckdb_pending_prepared_streaming(
      prepared_statement,
      out_result,
    );
  }

  late final _duckdb_pending_prepared_streamingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(duckdb_prepared_statement,
                  ffi.Pointer<duckdb_pending_result>)>>(
      'duckdb_pending_prepared_streaming');
  late final _duckdb_pending_prepared_streaming =
      _duckdb_pending_prepared_streamingPtr.asFunction<
          int Function(
              duckdb_prepared_statement, ffi.Pointer<duckdb_pending_result>)>();

  /// !
  /// Closes the pending result and de-allocates all memory allocated for the result.
  ///
  /// pending_result: The pending result to destroy.
  void duckdb_destroy_pending(
    ffi.Pointer<duckdb_pending_result> pending_result,
  ) {
    return _duckdb_destroy_pending(
      pending_result,
    );
  }

  late final _duckdb_destroy_pendingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<duckdb_pending_result>)>>('duckdb_destroy_pending');
  late final _duckdb_destroy_pending = _duckdb_destroy_pendingPtr
      .asFunction<void Function(ffi.Pointer<duckdb_pending_result>)>();

  /// !
  /// Returns the error message contained within the pending result.
  ///
  /// The result of this function must not be freed. It will be cleaned up when `duckdb_destroy_pending` is called.
  ///
  /// result: The pending result to fetch the error from.
  /// returns: The error of the pending result.
  ffi.Pointer<ffi.Char> duckdb_pending_error(
    duckdb_pending_result pending_result,
  ) {
    return _duckdb_pending_error(
      pending_result,
    );
  }

  late final _duckdb_pending_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_pending_result)>>('duckdb_pending_error');
  late final _duckdb_pending_error = _duckdb_pending_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_pending_result)>();

  /// !
  /// Executes a single task within the query, returning whether or not the query is ready.
  ///
  /// If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.
  /// If this returns DUCKDB_PENDING_RESULT_NOT_READY, the duckdb_pending_execute_task function should be called again.
  /// If this returns DUCKDB_PENDING_ERROR, an error occurred during execution.
  ///
  /// The error message can be obtained by calling duckdb_pending_error on the pending_result.
  ///
  /// pending_result: The pending result to execute a task within..
  /// returns: The state of the pending result after the execution.
  int duckdb_pending_execute_task(
    duckdb_pending_result pending_result,
  ) {
    return _duckdb_pending_execute_task(
      pending_result,
    );
  }

  late final _duckdb_pending_execute_taskPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_pending_result)>>(
          'duckdb_pending_execute_task');
  late final _duckdb_pending_execute_task = _duckdb_pending_execute_taskPtr
      .asFunction<int Function(duckdb_pending_result)>();

  /// !
  /// Fully execute a pending query result, returning the final query result.
  ///
  /// If duckdb_pending_execute_task has been called until DUCKDB_PENDING_RESULT_READY was returned, this will return fast.
  /// Otherwise, all remaining tasks must be executed first.
  ///
  /// pending_result: The pending result to execute.
  /// out_result: The result object.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_execute_pending(
    duckdb_pending_result pending_result,
    ffi.Pointer<duckdb_result> out_result,
  ) {
    return _duckdb_execute_pending(
      pending_result,
      out_result,
    );
  }

  late final _duckdb_execute_pendingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_pending_result,
              ffi.Pointer<duckdb_result>)>>('duckdb_execute_pending');
  late final _duckdb_execute_pending = _duckdb_execute_pendingPtr.asFunction<
      int Function(duckdb_pending_result, ffi.Pointer<duckdb_result>)>();

  /// !
  /// Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is
  /// DUCKDB_PENDING_RESULT_READY, this function will return true.
  ///
  /// pending_state: The pending state on which to decide whether to finish execution.
  /// returns: Boolean indicating pending execution should be considered finished.
  bool duckdb_pending_execution_is_finished(
    int pending_state,
  ) {
    return _duckdb_pending_execution_is_finished(
      pending_state,
    );
  }

  late final _duckdb_pending_execution_is_finishedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'duckdb_pending_execution_is_finished');
  late final _duckdb_pending_execution_is_finished =
      _duckdb_pending_execution_is_finishedPtr.asFunction<bool Function(int)>();

  /// ===--------------------------------------------------------------------===//
  /// Value Interface
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Destroys the value and de-allocates all memory allocated for that type.
  ///
  /// * value: The value to destroy.
  /// */
  void duckdb_destroy_value(
    ffi.Pointer<duckdb_value> value,
  ) {
    return _duckdb_destroy_value(
      value,
    );
  }

  late final _duckdb_destroy_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_value>)>>(
          'duckdb_destroy_value');
  late final _duckdb_destroy_value = _duckdb_destroy_valuePtr
      .asFunction<void Function(ffi.Pointer<duckdb_value>)>();

  /// !
  /// Creates a value from a null-terminated string
  ///
  /// value: The null-terminated string
  /// returns: The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_varchar(
    ffi.Pointer<ffi.Char> text,
  ) {
    return _duckdb_create_varchar(
      text,
    );
  }

  late final _duckdb_create_varcharPtr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Pointer<ffi.Char>)>>(
          'duckdb_create_varchar');
  late final _duckdb_create_varchar = _duckdb_create_varcharPtr
      .asFunction<duckdb_value Function(ffi.Pointer<ffi.Char>)>();

  /// !
  /// Creates a value from a string
  ///
  /// value: The text
  /// length: The length of the text
  /// returns: The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_varchar_length(
    ffi.Pointer<ffi.Char> text,
    int length,
  ) {
    return _duckdb_create_varchar_length(
      text,
      length,
    );
  }

  late final _duckdb_create_varchar_lengthPtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(
              ffi.Pointer<ffi.Char>, idx_t)>>('duckdb_create_varchar_length');
  late final _duckdb_create_varchar_length = _duckdb_create_varchar_lengthPtr
      .asFunction<duckdb_value Function(ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Creates a value from an int64
  ///
  /// value: The bigint value
  /// returns: The value. This must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_create_int64(
    int val,
  ) {
    return _duckdb_create_int64(
      val,
    );
  }

  late final _duckdb_create_int64Ptr =
      _lookup<ffi.NativeFunction<duckdb_value Function(ffi.Int64)>>(
          'duckdb_create_int64');
  late final _duckdb_create_int64 =
      _duckdb_create_int64Ptr.asFunction<duckdb_value Function(int)>();

  /// !
  /// Obtains a string representation of the given value.
  /// The result must be destroyed with `duckdb_free`.
  ///
  /// value: The value
  /// returns: The string value. This must be destroyed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_get_varchar(
    duckdb_value value,
  ) {
    return _duckdb_get_varchar(
      value,
    );
  }

  late final _duckdb_get_varcharPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_value)>>(
          'duckdb_get_varchar');
  late final _duckdb_get_varchar = _duckdb_get_varcharPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_value)>();

  /// !
  /// Obtains an int64 of the given value.
  ///
  /// value: The value
  /// returns: The int64 value, or 0 if no conversion is possible
  int duckdb_get_int64(
    duckdb_value value,
  ) {
    return _duckdb_get_int64(
      value,
    );
  }

  late final _duckdb_get_int64Ptr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(duckdb_value)>>(
          'duckdb_get_int64');
  late final _duckdb_get_int64 =
      _duckdb_get_int64Ptr.asFunction<int Function(duckdb_value)>();

  /// !
  /// Creates a `duckdb_logical_type` from a standard primitive type.
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// This should not be used with `DUCKDB_TYPE_DECIMAL`.
  ///
  /// type: The primitive type to create.
  /// returns: The logical type.
  duckdb_logical_type duckdb_create_logical_type(
    int type,
  ) {
    return _duckdb_create_logical_type(
      type,
    );
  }

  late final _duckdb_create_logical_typePtr =
      _lookup<ffi.NativeFunction<duckdb_logical_type Function(ffi.Int32)>>(
          'duckdb_create_logical_type');
  late final _duckdb_create_logical_type = _duckdb_create_logical_typePtr
      .asFunction<duckdb_logical_type Function(int)>();

  /// !
  /// Creates a list type from its child type.
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// type: The child type of list type to create.
  /// returns: The logical type.
  duckdb_logical_type duckdb_create_list_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_create_list_type(
      type,
    );
  }

  late final _duckdb_create_list_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type)>>('duckdb_create_list_type');
  late final _duckdb_create_list_type = _duckdb_create_list_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Creates a map type from its key type and value type.
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// type: The key type and value type of map type to create.
  /// returns: The logical type.
  duckdb_logical_type duckdb_create_map_type(
    duckdb_logical_type key_type,
    duckdb_logical_type value_type,
  ) {
    return _duckdb_create_map_type(
      key_type,
      value_type,
    );
  }

  late final _duckdb_create_map_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(duckdb_logical_type,
              duckdb_logical_type)>>('duckdb_create_map_type');
  late final _duckdb_create_map_type = _duckdb_create_map_typePtr.asFunction<
      duckdb_logical_type Function(duckdb_logical_type, duckdb_logical_type)>();

  /// !
  /// Creates a UNION type from the passed types array
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// types: The array of types that the union should consist of.
  /// type_amount: The size of the types array.
  /// returns: The logical type.
  duckdb_logical_type duckdb_create_union_type(
    duckdb_logical_type member_types,
    ffi.Pointer<ffi.Pointer<ffi.Char>> member_names,
    int member_count,
  ) {
    return _duckdb_create_union_type(
      member_types,
      member_names,
      member_count,
    );
  }

  late final _duckdb_create_union_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              idx_t)>>('duckdb_create_union_type');
  late final _duckdb_create_union_type =
      _duckdb_create_union_typePtr.asFunction<
          duckdb_logical_type Function(
              duckdb_logical_type, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// !
  /// Creates a STRUCT type from the passed member name and type arrays.
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// member_types: The array of types that the struct should consist of.
  /// member_names: The array of names that the struct should consist of.
  /// member_count: The number of members that were specified for both arrays.
  /// returns: The logical type.
  duckdb_logical_type duckdb_create_struct_type(
    ffi.Pointer<duckdb_logical_type> member_types,
    ffi.Pointer<ffi.Pointer<ffi.Char>> member_names,
    int member_count,
  ) {
    return _duckdb_create_struct_type(
      member_types,
      member_names,
      member_count,
    );
  }

  late final _duckdb_create_struct_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              ffi.Pointer<duckdb_logical_type>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              idx_t)>>('duckdb_create_struct_type');
  late final _duckdb_create_struct_type =
      _duckdb_create_struct_typePtr.asFunction<
          duckdb_logical_type Function(ffi.Pointer<duckdb_logical_type>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// !
  /// Creates a `duckdb_logical_type` of type decimal with the specified width and scale
  /// The resulting type should be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// width: The width of the decimal type
  /// scale: The scale of the decimal type
  /// returns: The logical type.
  duckdb_logical_type duckdb_create_decimal_type(
    int width,
    int scale,
  ) {
    return _duckdb_create_decimal_type(
      width,
      scale,
    );
  }

  late final _duckdb_create_decimal_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              ffi.Uint8, ffi.Uint8)>>('duckdb_create_decimal_type');
  late final _duckdb_create_decimal_type = _duckdb_create_decimal_typePtr
      .asFunction<duckdb_logical_type Function(int, int)>();

  /// !
  /// Retrieves the type class of a `duckdb_logical_type`.
  ///
  /// type: The logical type object
  /// returns: The type id
  int duckdb_get_type_id(
    duckdb_logical_type type,
  ) {
    return _duckdb_get_type_id(
      type,
    );
  }

  late final _duckdb_get_type_idPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_logical_type)>>(
          'duckdb_get_type_id');
  late final _duckdb_get_type_id =
      _duckdb_get_type_idPtr.asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the width of a decimal type.
  ///
  /// type: The logical type object
  /// returns: The width of the decimal type
  int duckdb_decimal_width(
    duckdb_logical_type type,
  ) {
    return _duckdb_decimal_width(
      type,
    );
  }

  late final _duckdb_decimal_widthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(duckdb_logical_type)>>(
          'duckdb_decimal_width');
  late final _duckdb_decimal_width =
      _duckdb_decimal_widthPtr.asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the scale of a decimal type.
  ///
  /// type: The logical type object
  /// returns: The scale of the decimal type
  int duckdb_decimal_scale(
    duckdb_logical_type type,
  ) {
    return _duckdb_decimal_scale(
      type,
    );
  }

  late final _duckdb_decimal_scalePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(duckdb_logical_type)>>(
          'duckdb_decimal_scale');
  late final _duckdb_decimal_scale =
      _duckdb_decimal_scalePtr.asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the internal storage type of a decimal type.
  ///
  /// type: The logical type object
  /// returns: The internal type of the decimal type
  int duckdb_decimal_internal_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_decimal_internal_type(
      type,
    );
  }

  late final _duckdb_decimal_internal_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_logical_type)>>(
          'duckdb_decimal_internal_type');
  late final _duckdb_decimal_internal_type = _duckdb_decimal_internal_typePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the internal storage type of an enum type.
  ///
  /// type: The logical type object
  /// returns: The internal type of the enum type
  int duckdb_enum_internal_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_enum_internal_type(
      type,
    );
  }

  late final _duckdb_enum_internal_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_logical_type)>>(
          'duckdb_enum_internal_type');
  late final _duckdb_enum_internal_type = _duckdb_enum_internal_typePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the dictionary size of the enum type
  ///
  /// type: The logical type object
  /// returns: The dictionary size of the enum type
  int duckdb_enum_dictionary_size(
    duckdb_logical_type type,
  ) {
    return _duckdb_enum_dictionary_size(
      type,
    );
  }

  late final _duckdb_enum_dictionary_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(duckdb_logical_type)>>(
          'duckdb_enum_dictionary_size');
  late final _duckdb_enum_dictionary_size = _duckdb_enum_dictionary_sizePtr
      .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the dictionary value at the specified position from the enum.
  ///
  /// The result must be freed with `duckdb_free`
  ///
  /// type: The logical type object
  /// index: The index in the dictionary
  /// returns: The string value of the enum type. Must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_enum_dictionary_value(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_enum_dictionary_value(
      type,
      index,
    );
  }

  late final _duckdb_enum_dictionary_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_logical_type, idx_t)>>('duckdb_enum_dictionary_value');
  late final _duckdb_enum_dictionary_value = _duckdb_enum_dictionary_valuePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type, int)>();

  /// !
  /// Retrieves the child type of the given list type.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`
  ///
  /// type: The logical type object
  /// returns: The child type of the list type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_list_type_child_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_list_type_child_type(
      type,
    );
  }

  late final _duckdb_list_type_child_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type)>>('duckdb_list_type_child_type');
  late final _duckdb_list_type_child_type = _duckdb_list_type_child_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the key type of the given map type.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`
  ///
  /// type: The logical type object
  /// returns: The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_map_type_key_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_map_type_key_type(
      type,
    );
  }

  late final _duckdb_map_type_key_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type)>>('duckdb_map_type_key_type');
  late final _duckdb_map_type_key_type = _duckdb_map_type_key_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the value type of the given map type.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`
  ///
  /// type: The logical type object
  /// returns: The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_map_type_value_type(
    duckdb_logical_type type,
  ) {
    return _duckdb_map_type_value_type(
      type,
    );
  }

  late final _duckdb_map_type_value_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type)>>('duckdb_map_type_value_type');
  late final _duckdb_map_type_value_type = _duckdb_map_type_value_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type)>();

  /// !
  /// Returns the number of children of a struct type.
  ///
  /// type: The logical type object
  /// returns: The number of children of a struct type.
  int duckdb_struct_type_child_count(
    duckdb_logical_type type,
  ) {
    return _duckdb_struct_type_child_count(
      type,
    );
  }

  late final _duckdb_struct_type_child_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_logical_type)>>(
          'duckdb_struct_type_child_count');
  late final _duckdb_struct_type_child_count =
      _duckdb_struct_type_child_countPtr
          .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the name of the struct child.
  ///
  /// The result must be freed with `duckdb_free`
  ///
  /// type: The logical type object
  /// index: The child index
  /// returns: The name of the struct type. Must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_struct_type_child_name(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_struct_type_child_name(
      type,
      index,
    );
  }

  late final _duckdb_struct_type_child_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_logical_type, idx_t)>>('duckdb_struct_type_child_name');
  late final _duckdb_struct_type_child_name = _duckdb_struct_type_child_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type, int)>();

  /// !
  /// Retrieves the child type of the given struct type at the specified index.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`
  ///
  /// type: The logical type object
  /// index: The child index
  /// returns: The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_struct_type_child_type(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_struct_type_child_type(
      type,
      index,
    );
  }

  late final _duckdb_struct_type_child_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type, idx_t)>>('duckdb_struct_type_child_type');
  late final _duckdb_struct_type_child_type = _duckdb_struct_type_child_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type, int)>();

  /// !
  /// Returns the number of members that the union type has.
  ///
  /// type: The logical type (union) object
  /// returns: The number of members of a union type.
  int duckdb_union_type_member_count(
    duckdb_logical_type type,
  ) {
    return _duckdb_union_type_member_count(
      type,
    );
  }

  late final _duckdb_union_type_member_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_logical_type)>>(
          'duckdb_union_type_member_count');
  late final _duckdb_union_type_member_count =
      _duckdb_union_type_member_countPtr
          .asFunction<int Function(duckdb_logical_type)>();

  /// !
  /// Retrieves the name of the union member.
  ///
  /// The result must be freed with `duckdb_free`
  ///
  /// type: The logical type object
  /// index: The child index
  /// returns: The name of the union member. Must be freed with `duckdb_free`.
  ffi.Pointer<ffi.Char> duckdb_union_type_member_name(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_union_type_member_name(
      type,
      index,
    );
  }

  late final _duckdb_union_type_member_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              duckdb_logical_type, idx_t)>>('duckdb_union_type_member_name');
  late final _duckdb_union_type_member_name = _duckdb_union_type_member_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_logical_type, int)>();

  /// !
  /// Retrieves the child type of the given union member at the specified index.
  ///
  /// The result must be freed with `duckdb_destroy_logical_type`
  ///
  /// type: The logical type object
  /// index: The child index
  /// returns: The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`.
  duckdb_logical_type duckdb_union_type_member_type(
    duckdb_logical_type type,
    int index,
  ) {
    return _duckdb_union_type_member_type(
      type,
      index,
    );
  }

  late final _duckdb_union_type_member_typePtr = _lookup<
      ffi.NativeFunction<
          duckdb_logical_type Function(
              duckdb_logical_type, idx_t)>>('duckdb_union_type_member_type');
  late final _duckdb_union_type_member_type = _duckdb_union_type_member_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_logical_type, int)>();

  /// !
  /// Destroys the logical type and de-allocates all memory allocated for that type.
  ///
  /// type: The logical type to destroy.
  void duckdb_destroy_logical_type(
    ffi.Pointer<duckdb_logical_type> type,
  ) {
    return _duckdb_destroy_logical_type(
      type,
    );
  }

  late final _duckdb_destroy_logical_typePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_logical_type>)>>(
      'duckdb_destroy_logical_type');
  late final _duckdb_destroy_logical_type = _duckdb_destroy_logical_typePtr
      .asFunction<void Function(ffi.Pointer<duckdb_logical_type>)>();

  /// ===--------------------------------------------------------------------===//
  /// Data Chunk Interface
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Creates an empty DataChunk with the specified set of types.
  ///
  /// * types: An array of types of the data chunk.
  /// * column_count: The number of columns.
  /// * returns: The data chunk.
  /// */
  duckdb_data_chunk duckdb_create_data_chunk(
    ffi.Pointer<duckdb_logical_type> types,
    int column_count,
  ) {
    return _duckdb_create_data_chunk(
      types,
      column_count,
    );
  }

  late final _duckdb_create_data_chunkPtr = _lookup<
      ffi.NativeFunction<
          duckdb_data_chunk Function(ffi.Pointer<duckdb_logical_type>,
              idx_t)>>('duckdb_create_data_chunk');
  late final _duckdb_create_data_chunk =
      _duckdb_create_data_chunkPtr.asFunction<
          duckdb_data_chunk Function(ffi.Pointer<duckdb_logical_type>, int)>();

  /// !
  /// Destroys the data chunk and de-allocates all memory allocated for that chunk.
  ///
  /// chunk: The data chunk to destroy.
  void duckdb_destroy_data_chunk(
    ffi.Pointer<duckdb_data_chunk> chunk,
  ) {
    return _duckdb_destroy_data_chunk(
      chunk,
    );
  }

  late final _duckdb_destroy_data_chunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<duckdb_data_chunk>)>>('duckdb_destroy_data_chunk');
  late final _duckdb_destroy_data_chunk = _duckdb_destroy_data_chunkPtr
      .asFunction<void Function(ffi.Pointer<duckdb_data_chunk>)>();

  /// !
  /// Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.
  ///
  /// chunk: The data chunk to reset.
  void duckdb_data_chunk_reset(
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_data_chunk_reset(
      chunk,
    );
  }

  late final _duckdb_data_chunk_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_data_chunk)>>(
          'duckdb_data_chunk_reset');
  late final _duckdb_data_chunk_reset = _duckdb_data_chunk_resetPtr
      .asFunction<void Function(duckdb_data_chunk)>();

  /// !
  /// Retrieves the number of columns in a data chunk.
  ///
  /// chunk: The data chunk to get the data from
  /// returns: The number of columns in the data chunk
  int duckdb_data_chunk_get_column_count(
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_data_chunk_get_column_count(
      chunk,
    );
  }

  late final _duckdb_data_chunk_get_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_data_chunk)>>(
          'duckdb_data_chunk_get_column_count');
  late final _duckdb_data_chunk_get_column_count =
      _duckdb_data_chunk_get_column_countPtr
          .asFunction<int Function(duckdb_data_chunk)>();

  /// !
  /// Retrieves the vector at the specified column index in the data chunk.
  ///
  /// The pointer to the vector is valid for as long as the chunk is alive.
  /// It does NOT need to be destroyed.
  ///
  /// chunk: The data chunk to get the data from
  /// returns: The vector
  duckdb_vector duckdb_data_chunk_get_vector(
    duckdb_data_chunk chunk,
    int col_idx,
  ) {
    return _duckdb_data_chunk_get_vector(
      chunk,
      col_idx,
    );
  }

  late final _duckdb_data_chunk_get_vectorPtr = _lookup<
          ffi.NativeFunction<duckdb_vector Function(duckdb_data_chunk, idx_t)>>(
      'duckdb_data_chunk_get_vector');
  late final _duckdb_data_chunk_get_vector = _duckdb_data_chunk_get_vectorPtr
      .asFunction<duckdb_vector Function(duckdb_data_chunk, int)>();

  /// !
  /// Retrieves the current number of tuples in a data chunk.
  ///
  /// chunk: The data chunk to get the data from
  /// returns: The number of tuples in the data chunk
  int duckdb_data_chunk_get_size(
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_data_chunk_get_size(
      chunk,
    );
  }

  late final _duckdb_data_chunk_get_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_data_chunk)>>(
          'duckdb_data_chunk_get_size');
  late final _duckdb_data_chunk_get_size = _duckdb_data_chunk_get_sizePtr
      .asFunction<int Function(duckdb_data_chunk)>();

  /// !
  /// Sets the current number of tuples in a data chunk.
  ///
  /// chunk: The data chunk to set the size in
  /// size: The number of tuples in the data chunk
  void duckdb_data_chunk_set_size(
    duckdb_data_chunk chunk,
    int size,
  ) {
    return _duckdb_data_chunk_set_size(
      chunk,
      size,
    );
  }

  late final _duckdb_data_chunk_set_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_data_chunk, idx_t)>>(
          'duckdb_data_chunk_set_size');
  late final _duckdb_data_chunk_set_size = _duckdb_data_chunk_set_sizePtr
      .asFunction<void Function(duckdb_data_chunk, int)>();

  /// ===--------------------------------------------------------------------===//
  /// Vector Interface
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Retrieves the column type of the specified vector.
  ///
  /// The result must be destroyed with `duckdb_destroy_logical_type`.
  ///
  /// * vector: The vector get the data from
  /// * returns: The type of the vector
  /// */
  duckdb_logical_type duckdb_vector_get_column_type(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_get_column_type(
      vector,
    );
  }

  late final _duckdb_vector_get_column_typePtr =
      _lookup<ffi.NativeFunction<duckdb_logical_type Function(duckdb_vector)>>(
          'duckdb_vector_get_column_type');
  late final _duckdb_vector_get_column_type = _duckdb_vector_get_column_typePtr
      .asFunction<duckdb_logical_type Function(duckdb_vector)>();

  /// !
  /// Retrieves the data pointer of the vector.
  ///
  /// The data pointer can be used to read or write values from the vector.
  /// How to read or write values depends on the type of the vector.
  ///
  /// vector: The vector to get the data from
  /// returns: The data pointer
  ffi.Pointer<ffi.Void> duckdb_vector_get_data(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_get_data(
      vector,
    );
  }

  late final _duckdb_vector_get_dataPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_vector)>>(
      'duckdb_vector_get_data');
  late final _duckdb_vector_get_data = _duckdb_vector_get_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_vector)>();

  /// !
  /// Retrieves the validity mask pointer of the specified vector.
  ///
  /// If all values are valid, this function MIGHT return NULL!
  ///
  /// The validity mask is a bitset that signifies null-ness within the data chunk.
  /// It is a series of uint64_t values, where each uint64_t value contains validity for 64 tuples.
  /// The bit is set to 1 if the value is valid (i.e. not NULL) or 0 if the value is invalid (i.e. NULL).
  ///
  /// Validity of a specific value can be obtained like this:
  ///
  /// idx_t entry_idx = row_idx / 64;
  /// idx_t idx_in_entry = row_idx % 64;
  /// bool is_valid = validity_mask[entry_idx] & (1 << idx_in_entry);
  ///
  /// Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.
  ///
  /// vector: The vector to get the data from
  /// returns: The pointer to the validity mask, or NULL if no validity mask is present
  ffi.Pointer<ffi.Uint64> duckdb_vector_get_validity(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_get_validity(
      vector,
    );
  }

  late final _duckdb_vector_get_validityPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Uint64> Function(duckdb_vector)>>(
      'duckdb_vector_get_validity');
  late final _duckdb_vector_get_validity = _duckdb_vector_get_validityPtr
      .asFunction<ffi.Pointer<ffi.Uint64> Function(duckdb_vector)>();

  /// !
  /// Ensures the validity mask is writable by allocating it.
  ///
  /// After this function is called, `duckdb_vector_get_validity` will ALWAYS return non-NULL.
  /// This allows null values to be written to the vector, regardless of whether a validity mask was present before.
  ///
  /// vector: The vector to alter
  void duckdb_vector_ensure_validity_writable(
    duckdb_vector vector,
  ) {
    return _duckdb_vector_ensure_validity_writable(
      vector,
    );
  }

  late final _duckdb_vector_ensure_validity_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_vector)>>(
          'duckdb_vector_ensure_validity_writable');
  late final _duckdb_vector_ensure_validity_writable =
      _duckdb_vector_ensure_validity_writablePtr
          .asFunction<void Function(duckdb_vector)>();

  /// !
  /// Assigns a string element in the vector at the specified location.
  ///
  /// vector: The vector to alter
  /// index: The row position in the vector to assign the string to
  /// str: The null-terminated string
  void duckdb_vector_assign_string_element(
    duckdb_vector vector,
    int index,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _duckdb_vector_assign_string_element(
      vector,
      index,
      str,
    );
  }

  late final _duckdb_vector_assign_string_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_vector, idx_t,
              ffi.Pointer<ffi.Char>)>>('duckdb_vector_assign_string_element');
  late final _duckdb_vector_assign_string_element =
      _duckdb_vector_assign_string_elementPtr.asFunction<
          void Function(duckdb_vector, int, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Assigns a string element in the vector at the specified location.
  ///
  /// vector: The vector to alter
  /// index: The row position in the vector to assign the string to
  /// str: The string
  /// str_len: The length of the string (in bytes)
  void duckdb_vector_assign_string_element_len(
    duckdb_vector vector,
    int index,
    ffi.Pointer<ffi.Char> str,
    int str_len,
  ) {
    return _duckdb_vector_assign_string_element_len(
      vector,
      index,
      str,
      str_len,
    );
  }

  late final _duckdb_vector_assign_string_element_lenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_vector, idx_t, ffi.Pointer<ffi.Char>,
              idx_t)>>('duckdb_vector_assign_string_element_len');
  late final _duckdb_vector_assign_string_element_len =
      _duckdb_vector_assign_string_element_lenPtr.asFunction<
          void Function(duckdb_vector, int, ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Retrieves the child vector of a list vector.
  ///
  /// The resulting vector is valid as long as the parent vector is valid.
  ///
  /// vector: The vector
  /// returns: The child vector
  duckdb_vector duckdb_list_vector_get_child(
    duckdb_vector vector,
  ) {
    return _duckdb_list_vector_get_child(
      vector,
    );
  }

  late final _duckdb_list_vector_get_childPtr =
      _lookup<ffi.NativeFunction<duckdb_vector Function(duckdb_vector)>>(
          'duckdb_list_vector_get_child');
  late final _duckdb_list_vector_get_child = _duckdb_list_vector_get_childPtr
      .asFunction<duckdb_vector Function(duckdb_vector)>();

  /// !
  /// Returns the size of the child vector of the list
  ///
  /// vector: The vector
  /// returns: The size of the child list
  int duckdb_list_vector_get_size(
    duckdb_vector vector,
  ) {
    return _duckdb_list_vector_get_size(
      vector,
    );
  }

  late final _duckdb_list_vector_get_sizePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_vector)>>(
          'duckdb_list_vector_get_size');
  late final _duckdb_list_vector_get_size =
      _duckdb_list_vector_get_sizePtr.asFunction<int Function(duckdb_vector)>();

  /// !
  /// Sets the total size of the underlying child-vector of a list vector.
  ///
  /// vector: The list vector.
  /// size: The size of the child list.
  /// returns: The duckdb state. Returns DuckDBError if the vector is nullptr.
  int duckdb_list_vector_set_size(
    duckdb_vector vector,
    int size,
  ) {
    return _duckdb_list_vector_set_size(
      vector,
      size,
    );
  }

  late final _duckdb_list_vector_set_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_vector, idx_t)>>(
          'duckdb_list_vector_set_size');
  late final _duckdb_list_vector_set_size = _duckdb_list_vector_set_sizePtr
      .asFunction<int Function(duckdb_vector, int)>();

  /// !
  /// Sets the total capacity of the underlying child-vector of a list.
  ///
  /// vector: The list vector.
  /// required_capacity: the total capacity to reserve.
  /// return: The duckdb state. Returns DuckDBError if the vector is nullptr.
  int duckdb_list_vector_reserve(
    duckdb_vector vector,
    int required_capacity,
  ) {
    return _duckdb_list_vector_reserve(
      vector,
      required_capacity,
    );
  }

  late final _duckdb_list_vector_reservePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_vector, idx_t)>>(
          'duckdb_list_vector_reserve');
  late final _duckdb_list_vector_reserve = _duckdb_list_vector_reservePtr
      .asFunction<int Function(duckdb_vector, int)>();

  /// !
  /// Retrieves the child vector of a struct vector.
  ///
  /// The resulting vector is valid as long as the parent vector is valid.
  ///
  /// vector: The vector
  /// index: The child index
  /// returns: The child vector
  duckdb_vector duckdb_struct_vector_get_child(
    duckdb_vector vector,
    int index,
  ) {
    return _duckdb_struct_vector_get_child(
      vector,
      index,
    );
  }

  late final _duckdb_struct_vector_get_childPtr =
      _lookup<ffi.NativeFunction<duckdb_vector Function(duckdb_vector, idx_t)>>(
          'duckdb_struct_vector_get_child');
  late final _duckdb_struct_vector_get_child =
      _duckdb_struct_vector_get_childPtr
          .asFunction<duckdb_vector Function(duckdb_vector, int)>();

  /// ===--------------------------------------------------------------------===//
  /// Validity Mask Functions
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Returns whether or not a row is valid (i.e. not NULL) in the given validity mask.
  ///
  /// * validity: The validity mask, as obtained through `duckdb_vector_get_validity`
  /// * row: The row index
  /// * returns: true if the row is valid, false otherwise
  /// */
  bool duckdb_validity_row_is_valid(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
  ) {
    return _duckdb_validity_row_is_valid(
      validity,
      row,
    );
  }

  late final _duckdb_validity_row_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Uint64>, idx_t)>>('duckdb_validity_row_is_valid');
  late final _duckdb_validity_row_is_valid = _duckdb_validity_row_is_validPtr
      .asFunction<bool Function(ffi.Pointer<ffi.Uint64>, int)>();

  /// !
  /// In a validity mask, sets a specific row to either valid or invalid.
  ///
  /// Note that `duckdb_vector_ensure_validity_writable` should be called before calling `duckdb_vector_get_validity`,
  /// to ensure that there is a validity mask to write to.
  ///
  /// validity: The validity mask, as obtained through `duckdb_vector_get_validity`.
  /// row: The row index
  /// valid: Whether or not to set the row to valid, or invalid
  void duckdb_validity_set_row_validity(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
    bool valid,
  ) {
    return _duckdb_validity_set_row_validity(
      validity,
      row,
      valid,
    );
  }

  late final _duckdb_validity_set_row_validityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint64>, idx_t,
              ffi.Bool)>>('duckdb_validity_set_row_validity');
  late final _duckdb_validity_set_row_validity =
      _duckdb_validity_set_row_validityPtr
          .asFunction<void Function(ffi.Pointer<ffi.Uint64>, int, bool)>();

  /// !
  /// In a validity mask, sets a specific row to invalid.
  ///
  /// Equivalent to `duckdb_validity_set_row_validity` with valid set to false.
  ///
  /// validity: The validity mask
  /// row: The row index
  void duckdb_validity_set_row_invalid(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
  ) {
    return _duckdb_validity_set_row_invalid(
      validity,
      row,
    );
  }

  late final _duckdb_validity_set_row_invalidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint64>,
              idx_t)>>('duckdb_validity_set_row_invalid');
  late final _duckdb_validity_set_row_invalid =
      _duckdb_validity_set_row_invalidPtr
          .asFunction<void Function(ffi.Pointer<ffi.Uint64>, int)>();

  /// !
  /// In a validity mask, sets a specific row to valid.
  ///
  /// Equivalent to `duckdb_validity_set_row_validity` with valid set to true.
  ///
  /// validity: The validity mask
  /// row: The row index
  void duckdb_validity_set_row_valid(
    ffi.Pointer<ffi.Uint64> validity,
    int row,
  ) {
    return _duckdb_validity_set_row_valid(
      validity,
      row,
    );
  }

  late final _duckdb_validity_set_row_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint64>,
              idx_t)>>('duckdb_validity_set_row_valid');
  late final _duckdb_validity_set_row_valid = _duckdb_validity_set_row_validPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint64>, int)>();

  /// !
  /// Creates a new empty table function.
  ///
  /// The return value should be destroyed with `duckdb_destroy_table_function`.
  ///
  /// returns: The table function object.
  duckdb_table_function duckdb_create_table_function() {
    return _duckdb_create_table_function();
  }

  late final _duckdb_create_table_functionPtr =
      _lookup<ffi.NativeFunction<duckdb_table_function Function()>>(
          'duckdb_create_table_function');
  late final _duckdb_create_table_function = _duckdb_create_table_functionPtr
      .asFunction<duckdb_table_function Function()>();

  /// !
  /// Destroys the given table function object.
  ///
  /// table_function: The table function to destroy
  void duckdb_destroy_table_function(
    ffi.Pointer<duckdb_table_function> table_function,
  ) {
    return _duckdb_destroy_table_function(
      table_function,
    );
  }

  late final _duckdb_destroy_table_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<duckdb_table_function>)>>(
      'duckdb_destroy_table_function');
  late final _duckdb_destroy_table_function = _duckdb_destroy_table_functionPtr
      .asFunction<void Function(ffi.Pointer<duckdb_table_function>)>();

  /// !
  /// Sets the name of the given table function.
  ///
  /// table_function: The table function
  /// name: The name of the table function
  void duckdb_table_function_set_name(
    duckdb_table_function table_function,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_table_function_set_name(
      table_function,
      name,
    );
  }

  late final _duckdb_table_function_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              ffi.Pointer<ffi.Char>)>>('duckdb_table_function_set_name');
  late final _duckdb_table_function_set_name =
      _duckdb_table_function_set_namePtr.asFunction<
          void Function(duckdb_table_function, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Adds a parameter to the table function.
  ///
  /// table_function: The table function
  /// type: The type of the parameter to add.
  void duckdb_table_function_add_parameter(
    duckdb_table_function table_function,
    duckdb_logical_type type,
  ) {
    return _duckdb_table_function_add_parameter(
      table_function,
      type,
    );
  }

  late final _duckdb_table_function_add_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_logical_type)>>('duckdb_table_function_add_parameter');
  late final _duckdb_table_function_add_parameter =
      _duckdb_table_function_add_parameterPtr.asFunction<
          void Function(duckdb_table_function, duckdb_logical_type)>();

  /// !
  /// Adds a named parameter to the table function.
  ///
  /// table_function: The table function
  /// name: The name of the parameter
  /// type: The type of the parameter to add.
  void duckdb_table_function_add_named_parameter(
    duckdb_table_function table_function,
    ffi.Pointer<ffi.Char> name,
    duckdb_logical_type type,
  ) {
    return _duckdb_table_function_add_named_parameter(
      table_function,
      name,
      type,
    );
  }

  late final _duckdb_table_function_add_named_parameterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_table_function, ffi.Pointer<ffi.Char>,
                  duckdb_logical_type)>>(
      'duckdb_table_function_add_named_parameter');
  late final _duckdb_table_function_add_named_parameter =
      _duckdb_table_function_add_named_parameterPtr.asFunction<
          void Function(duckdb_table_function, ffi.Pointer<ffi.Char>,
              duckdb_logical_type)>();

  /// !
  /// Assigns extra information to the table function that can be fetched during binding, etc.
  ///
  /// table_function: The table function
  /// extra_info: The extra information
  /// destroy: The callback that will be called to destroy the bind data (if any)
  void duckdb_table_function_set_extra_info(
    duckdb_table_function table_function,
    ffi.Pointer<ffi.Void> extra_info,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_table_function_set_extra_info(
      table_function,
      extra_info,
      destroy,
    );
  }

  late final _duckdb_table_function_set_extra_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(duckdb_table_function, ffi.Pointer<ffi.Void>,
                  duckdb_delete_callback_t)>>(
      'duckdb_table_function_set_extra_info');
  late final _duckdb_table_function_set_extra_info =
      _duckdb_table_function_set_extra_infoPtr.asFunction<
          void Function(duckdb_table_function, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Sets the bind function of the table function
  ///
  /// table_function: The table function
  /// bind: The bind function
  void duckdb_table_function_set_bind(
    duckdb_table_function table_function,
    duckdb_table_function_bind_t bind,
  ) {
    return _duckdb_table_function_set_bind(
      table_function,
      bind,
    );
  }

  late final _duckdb_table_function_set_bindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_table_function_bind_t)>>('duckdb_table_function_set_bind');
  late final _duckdb_table_function_set_bind =
      _duckdb_table_function_set_bindPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_bind_t)>();

  /// !
  /// Sets the init function of the table function
  ///
  /// table_function: The table function
  /// init: The init function
  void duckdb_table_function_set_init(
    duckdb_table_function table_function,
    duckdb_table_function_init_t init,
  ) {
    return _duckdb_table_function_set_init(
      table_function,
      init,
    );
  }

  late final _duckdb_table_function_set_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_table_function_init_t)>>('duckdb_table_function_set_init');
  late final _duckdb_table_function_set_init =
      _duckdb_table_function_set_initPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_init_t)>();

  /// !
  /// Sets the thread-local init function of the table function
  ///
  /// table_function: The table function
  /// init: The init function
  void duckdb_table_function_set_local_init(
    duckdb_table_function table_function,
    duckdb_table_function_init_t init,
  ) {
    return _duckdb_table_function_set_local_init(
      table_function,
      init,
    );
  }

  late final _duckdb_table_function_set_local_initPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_table_function, duckdb_table_function_init_t)>>(
      'duckdb_table_function_set_local_init');
  late final _duckdb_table_function_set_local_init =
      _duckdb_table_function_set_local_initPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_init_t)>();

  /// !
  /// Sets the main function of the table function
  ///
  /// table_function: The table function
  /// function: The function
  void duckdb_table_function_set_function(
    duckdb_table_function table_function,
    duckdb_table_function_t function,
  ) {
    return _duckdb_table_function_set_function(
      table_function,
      function,
    );
  }

  late final _duckdb_table_function_set_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              duckdb_table_function_t)>>('duckdb_table_function_set_function');
  late final _duckdb_table_function_set_function =
      _duckdb_table_function_set_functionPtr.asFunction<
          void Function(duckdb_table_function, duckdb_table_function_t)>();

  /// !
  /// Sets whether or not the given table function supports projection pushdown.
  ///
  /// If this is set to true, the system will provide a list of all required columns in the `init` stage through
  /// the `duckdb_init_get_column_count` and `duckdb_init_get_column_index` functions.
  /// If this is set to false (the default), the system will expect all columns to be projected.
  ///
  /// table_function: The table function
  /// pushdown: True if the table function supports projection pushdown, false otherwise.
  void duckdb_table_function_supports_projection_pushdown(
    duckdb_table_function table_function,
    bool pushdown,
  ) {
    return _duckdb_table_function_supports_projection_pushdown(
      table_function,
      pushdown,
    );
  }

  late final _duckdb_table_function_supports_projection_pushdownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_table_function,
              ffi.Bool)>>('duckdb_table_function_supports_projection_pushdown');
  late final _duckdb_table_function_supports_projection_pushdown =
      _duckdb_table_function_supports_projection_pushdownPtr
          .asFunction<void Function(duckdb_table_function, bool)>();

  /// !
  /// Register the table function object within the given connection.
  ///
  /// The function requires at least a name, a bind function, an init function and a main function.
  ///
  /// If the function is incomplete or a function with this name already exists DuckDBError is returned.
  ///
  /// con: The connection to register it in.
  /// function: The function pointer
  /// returns: Whether or not the registration was successful.
  int duckdb_register_table_function(
    duckdb_connection con,
    duckdb_table_function function,
  ) {
    return _duckdb_register_table_function(
      con,
      function,
    );
  }

  late final _duckdb_register_table_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_connection,
              duckdb_table_function)>>('duckdb_register_table_function');
  late final _duckdb_register_table_function =
      _duckdb_register_table_functionPtr
          .asFunction<int Function(duckdb_connection, duckdb_table_function)>();

  /// ===--------------------------------------------------------------------===//
  /// Table Function Bind
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
  ///
  /// * info: The info object
  /// * returns: The extra info
  /// */
  ffi.Pointer<ffi.Void> duckdb_bind_get_extra_info(
    duckdb_bind_info info,
  ) {
    return _duckdb_bind_get_extra_info(
      info,
    );
  }

  late final _duckdb_bind_get_extra_infoPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_bind_info)>>(
      'duckdb_bind_get_extra_info');
  late final _duckdb_bind_get_extra_info = _duckdb_bind_get_extra_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_bind_info)>();

  /// !
  /// Adds a result column to the output of the table function.
  ///
  /// info: The info object
  /// name: The name of the column
  /// type: The logical type of the column
  void duckdb_bind_add_result_column(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Char> name,
    duckdb_logical_type type,
  ) {
    return _duckdb_bind_add_result_column(
      info,
      name,
      type,
    );
  }

  late final _duckdb_bind_add_result_columnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info, ffi.Pointer<ffi.Char>,
              duckdb_logical_type)>>('duckdb_bind_add_result_column');
  late final _duckdb_bind_add_result_column =
      _duckdb_bind_add_result_columnPtr.asFunction<
          void Function(
              duckdb_bind_info, ffi.Pointer<ffi.Char>, duckdb_logical_type)>();

  /// !
  /// Retrieves the number of regular (non-named) parameters to the function.
  ///
  /// info: The info object
  /// returns: The number of parameters
  int duckdb_bind_get_parameter_count(
    duckdb_bind_info info,
  ) {
    return _duckdb_bind_get_parameter_count(
      info,
    );
  }

  late final _duckdb_bind_get_parameter_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_bind_info)>>(
          'duckdb_bind_get_parameter_count');
  late final _duckdb_bind_get_parameter_count =
      _duckdb_bind_get_parameter_countPtr
          .asFunction<int Function(duckdb_bind_info)>();

  /// !
  /// Retrieves the parameter at the given index.
  ///
  /// The result must be destroyed with `duckdb_destroy_value`.
  ///
  /// info: The info object
  /// index: The index of the parameter to get
  /// returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_bind_get_parameter(
    duckdb_bind_info info,
    int index,
  ) {
    return _duckdb_bind_get_parameter(
      info,
      index,
    );
  }

  late final _duckdb_bind_get_parameterPtr = _lookup<
          ffi.NativeFunction<duckdb_value Function(duckdb_bind_info, idx_t)>>(
      'duckdb_bind_get_parameter');
  late final _duckdb_bind_get_parameter = _duckdb_bind_get_parameterPtr
      .asFunction<duckdb_value Function(duckdb_bind_info, int)>();

  /// !
  /// Retrieves a named parameter with the given name.
  ///
  /// The result must be destroyed with `duckdb_destroy_value`.
  ///
  /// info: The info object
  /// name: The name of the parameter
  /// returns: The value of the parameter. Must be destroyed with `duckdb_destroy_value`.
  duckdb_value duckdb_bind_get_named_parameter(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _duckdb_bind_get_named_parameter(
      info,
      name,
    );
  }

  late final _duckdb_bind_get_named_parameterPtr = _lookup<
      ffi.NativeFunction<
          duckdb_value Function(duckdb_bind_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_get_named_parameter');
  late final _duckdb_bind_get_named_parameter =
      _duckdb_bind_get_named_parameterPtr.asFunction<
          duckdb_value Function(duckdb_bind_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.
  ///
  /// info: The info object
  /// extra_data: The bind data object.
  /// destroy: The callback that will be called to destroy the bind data (if any)
  void duckdb_bind_set_bind_data(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Void> bind_data,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_bind_set_bind_data(
      info,
      bind_data,
      destroy,
    );
  }

  late final _duckdb_bind_set_bind_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>>('duckdb_bind_set_bind_data');
  late final _duckdb_bind_set_bind_data =
      _duckdb_bind_set_bind_dataPtr.asFunction<
          void Function(duckdb_bind_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Sets the cardinality estimate for the table function, used for optimization.
  ///
  /// info: The bind data object.
  /// is_exact: Whether or not the cardinality estimate is exact, or an approximation
  void duckdb_bind_set_cardinality(
    duckdb_bind_info info,
    int cardinality,
    bool is_exact,
  ) {
    return _duckdb_bind_set_cardinality(
      info,
      cardinality,
      is_exact,
    );
  }

  late final _duckdb_bind_set_cardinalityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info, idx_t,
              ffi.Bool)>>('duckdb_bind_set_cardinality');
  late final _duckdb_bind_set_cardinality = _duckdb_bind_set_cardinalityPtr
      .asFunction<void Function(duckdb_bind_info, int, bool)>();

  /// !
  /// Report that an error has occurred while calling bind.
  ///
  /// info: The info object
  /// error: The error message
  void duckdb_bind_set_error(
    duckdb_bind_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_bind_set_error(
      info,
      error,
    );
  }

  late final _duckdb_bind_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_bind_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_bind_set_error');
  late final _duckdb_bind_set_error = _duckdb_bind_set_errorPtr
      .asFunction<void Function(duckdb_bind_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
  ///
  /// info: The info object
  /// returns: The extra info
  ffi.Pointer<ffi.Void> duckdb_init_get_extra_info(
    duckdb_init_info info,
  ) {
    return _duckdb_init_get_extra_info(
      info,
    );
  }

  late final _duckdb_init_get_extra_infoPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>>(
      'duckdb_init_get_extra_info');
  late final _duckdb_init_get_extra_info = _duckdb_init_get_extra_infoPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>();

  /// !
  /// Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
  ///
  /// Note that the bind data should be considered as read-only.
  /// For tracking state, use the init data instead.
  ///
  /// info: The info object
  /// returns: The bind data object
  ffi.Pointer<ffi.Void> duckdb_init_get_bind_data(
    duckdb_init_info info,
  ) {
    return _duckdb_init_get_bind_data(
      info,
    );
  }

  late final _duckdb_init_get_bind_dataPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>>(
      'duckdb_init_get_bind_data');
  late final _duckdb_init_get_bind_data = _duckdb_init_get_bind_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_init_info)>();

  /// !
  /// Sets the user-provided init data in the init object. This object can be retrieved again during execution.
  ///
  /// info: The info object
  /// extra_data: The init data object.
  /// destroy: The callback that will be called to destroy the init data (if any)
  void duckdb_init_set_init_data(
    duckdb_init_info info,
    ffi.Pointer<ffi.Void> init_data,
    duckdb_delete_callback_t destroy,
  ) {
    return _duckdb_init_set_init_data(
      info,
      init_data,
      destroy,
    );
  }

  late final _duckdb_init_set_init_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_init_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>>('duckdb_init_set_init_data');
  late final _duckdb_init_set_init_data =
      _duckdb_init_set_init_dataPtr.asFunction<
          void Function(duckdb_init_info, ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>();

  /// !
  /// Returns the number of projected columns.
  ///
  /// This function must be used if projection pushdown is enabled to figure out which columns to emit.
  ///
  /// info: The info object
  /// returns: The number of projected columns.
  int duckdb_init_get_column_count(
    duckdb_init_info info,
  ) {
    return _duckdb_init_get_column_count(
      info,
    );
  }

  late final _duckdb_init_get_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_init_info)>>(
          'duckdb_init_get_column_count');
  late final _duckdb_init_get_column_count = _duckdb_init_get_column_countPtr
      .asFunction<int Function(duckdb_init_info)>();

  /// !
  /// Returns the column index of the projected column at the specified position.
  ///
  /// This function must be used if projection pushdown is enabled to figure out which columns to emit.
  ///
  /// info: The info object
  /// column_index: The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)
  /// returns: The column index of the projected column.
  int duckdb_init_get_column_index(
    duckdb_init_info info,
    int column_index,
  ) {
    return _duckdb_init_get_column_index(
      info,
      column_index,
    );
  }

  late final _duckdb_init_get_column_indexPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_init_info, idx_t)>>(
          'duckdb_init_get_column_index');
  late final _duckdb_init_get_column_index = _duckdb_init_get_column_indexPtr
      .asFunction<int Function(duckdb_init_info, int)>();

  /// !
  /// Sets how many threads can process this table function in parallel (default: 1)
  ///
  /// info: The info object
  /// max_threads: The maximum amount of threads that can process this table function
  void duckdb_init_set_max_threads(
    duckdb_init_info info,
    int max_threads,
  ) {
    return _duckdb_init_set_max_threads(
      info,
      max_threads,
    );
  }

  late final _duckdb_init_set_max_threadsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_init_info, idx_t)>>(
          'duckdb_init_set_max_threads');
  late final _duckdb_init_set_max_threads = _duckdb_init_set_max_threadsPtr
      .asFunction<void Function(duckdb_init_info, int)>();

  /// !
  /// Report that an error has occurred while calling init.
  ///
  /// info: The info object
  /// error: The error message
  void duckdb_init_set_error(
    duckdb_init_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_init_set_error(
      info,
      error,
    );
  }

  late final _duckdb_init_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_init_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_init_set_error');
  late final _duckdb_init_set_error = _duckdb_init_set_errorPtr
      .asFunction<void Function(duckdb_init_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Retrieves the extra info of the function as set in `duckdb_table_function_set_extra_info`
  ///
  /// info: The info object
  /// returns: The extra info
  ffi.Pointer<ffi.Void> duckdb_function_get_extra_info(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_extra_info(
      info,
    );
  }

  late final _duckdb_function_get_extra_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_extra_info');
  late final _duckdb_function_get_extra_info =
      _duckdb_function_get_extra_infoPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.
  ///
  /// Note that the bind data should be considered as read-only.
  /// For tracking state, use the init data instead.
  ///
  /// info: The info object
  /// returns: The bind data object
  ffi.Pointer<ffi.Void> duckdb_function_get_bind_data(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_bind_data(
      info,
    );
  }

  late final _duckdb_function_get_bind_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_bind_data');
  late final _duckdb_function_get_bind_data = _duckdb_function_get_bind_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Gets the init data set by `duckdb_init_set_init_data` during the init.
  ///
  /// info: The info object
  /// returns: The init data object
  ffi.Pointer<ffi.Void> duckdb_function_get_init_data(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_init_data(
      info,
    );
  }

  late final _duckdb_function_get_init_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_init_data');
  late final _duckdb_function_get_init_data = _duckdb_function_get_init_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.
  ///
  /// info: The info object
  /// returns: The init data object
  ffi.Pointer<ffi.Void> duckdb_function_get_local_init_data(
    duckdb_function_info info,
  ) {
    return _duckdb_function_get_local_init_data(
      info,
    );
  }

  late final _duckdb_function_get_local_init_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              duckdb_function_info)>>('duckdb_function_get_local_init_data');
  late final _duckdb_function_get_local_init_data =
      _duckdb_function_get_local_init_dataPtr
          .asFunction<ffi.Pointer<ffi.Void> Function(duckdb_function_info)>();

  /// !
  /// Report that an error has occurred while executing the function.
  ///
  /// info: The info object
  /// error: The error message
  void duckdb_function_set_error(
    duckdb_function_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_function_set_error(
      info,
      error,
    );
  }

  late final _duckdb_function_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_function_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_function_set_error');
  late final _duckdb_function_set_error = _duckdb_function_set_errorPtr
      .asFunction<void Function(duckdb_function_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Add a replacement scan definition to the specified database
  ///
  /// db: The database object to add the replacement scan to
  /// replacement: The replacement scan callback
  /// extra_data: Extra data that is passed back into the specified callback
  /// delete_callback: The delete callback to call on the extra data, if any
  void duckdb_add_replacement_scan(
    duckdb_database db,
    duckdb_replacement_callback_t replacement,
    ffi.Pointer<ffi.Void> extra_data,
    duckdb_delete_callback_t delete_callback,
  ) {
    return _duckdb_add_replacement_scan(
      db,
      replacement,
      extra_data,
      delete_callback,
    );
  }

  late final _duckdb_add_replacement_scanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              duckdb_database,
              duckdb_replacement_callback_t,
              ffi.Pointer<ffi.Void>,
              duckdb_delete_callback_t)>>('duckdb_add_replacement_scan');
  late final _duckdb_add_replacement_scan =
      _duckdb_add_replacement_scanPtr.asFunction<
          void Function(duckdb_database, duckdb_replacement_callback_t,
              ffi.Pointer<ffi.Void>, duckdb_delete_callback_t)>();

  /// !
  /// Sets the replacement function name to use. If this function is called in the replacement callback,
  /// the replacement scan is performed. If it is not called, the replacement callback is not performed.
  ///
  /// info: The info object
  /// function_name: The function name to substitute.
  void duckdb_replacement_scan_set_function_name(
    duckdb_replacement_scan_info info,
    ffi.Pointer<ffi.Char> function_name,
  ) {
    return _duckdb_replacement_scan_set_function_name(
      info,
      function_name,
    );
  }

  late final _duckdb_replacement_scan_set_function_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>)>>(
      'duckdb_replacement_scan_set_function_name');
  late final _duckdb_replacement_scan_set_function_name =
      _duckdb_replacement_scan_set_function_namePtr.asFunction<
          void Function(duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Adds a parameter to the replacement scan function.
  ///
  /// info: The info object
  /// parameter: The parameter to add.
  void duckdb_replacement_scan_add_parameter(
    duckdb_replacement_scan_info info,
    duckdb_value parameter,
  ) {
    return _duckdb_replacement_scan_add_parameter(
      info,
      parameter,
    );
  }

  late final _duckdb_replacement_scan_add_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_replacement_scan_info,
              duckdb_value)>>('duckdb_replacement_scan_add_parameter');
  late final _duckdb_replacement_scan_add_parameter =
      _duckdb_replacement_scan_add_parameterPtr.asFunction<
          void Function(duckdb_replacement_scan_info, duckdb_value)>();

  /// !
  /// Report that an error has occurred while executing the replacement scan.
  ///
  /// info: The info object
  /// error: The error message
  void duckdb_replacement_scan_set_error(
    duckdb_replacement_scan_info info,
    ffi.Pointer<ffi.Char> error,
  ) {
    return _duckdb_replacement_scan_set_error(
      info,
      error,
    );
  }

  late final _duckdb_replacement_scan_set_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(duckdb_replacement_scan_info,
              ffi.Pointer<ffi.Char>)>>('duckdb_replacement_scan_set_error');
  late final _duckdb_replacement_scan_set_error =
      _duckdb_replacement_scan_set_errorPtr.asFunction<
          void Function(duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Creates an appender object.
  ///
  /// connection: The connection context to create the appender in.
  /// schema: The schema of the table to append to, or `nullptr` for the default schema.
  /// table: The table name to append to.
  /// out_appender: The resulting appender object.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_appender_create(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> schema,
    ffi.Pointer<ffi.Char> table,
    ffi.Pointer<duckdb_appender> out_appender,
  ) {
    return _duckdb_appender_create(
      connection,
      schema,
      table,
      out_appender,
    );
  }

  late final _duckdb_appender_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_connection,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_appender>)>>('duckdb_appender_create');
  late final _duckdb_appender_create = _duckdb_appender_createPtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<duckdb_appender>)>();

  /// !
  /// Returns the error message associated with the given appender.
  /// If the appender has no error message, this returns `nullptr` instead.
  ///
  /// The error message should not be freed. It will be de-allocated when `duckdb_appender_destroy` is called.
  ///
  /// appender: The appender to get the error from.
  /// returns: The error message, or `nullptr` if there is none.
  ffi.Pointer<ffi.Char> duckdb_appender_error(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_error(
      appender,
    );
  }

  late final _duckdb_appender_errorPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_appender)>>(
      'duckdb_appender_error');
  late final _duckdb_appender_error = _duckdb_appender_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_appender)>();

  /// !
  /// Flush the appender to the table, forcing the cache of the appender to be cleared and the data to be appended to the
  /// base table.
  ///
  /// This should generally not be used unless you know what you are doing. Instead, call `duckdb_appender_destroy` when you
  /// are done with the appender.
  ///
  /// appender: The appender to flush.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_appender_flush(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_flush(
      appender,
    );
  }

  late final _duckdb_appender_flushPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_appender)>>(
          'duckdb_appender_flush');
  late final _duckdb_appender_flush =
      _duckdb_appender_flushPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Close the appender, flushing all intermediate state in the appender to the table and closing it for further appends.
  ///
  /// This is generally not necessary. Call `duckdb_appender_destroy` instead.
  ///
  /// appender: The appender to flush and close.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_appender_close(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_close(
      appender,
    );
  }

  late final _duckdb_appender_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_appender)>>(
          'duckdb_appender_close');
  late final _duckdb_appender_close =
      _duckdb_appender_closePtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Close the appender and destroy it. Flushing all intermediate state in the appender to the table, and de-allocating
  /// all memory associated with the appender.
  ///
  /// appender: The appender to flush, close and destroy.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_appender_destroy(
    ffi.Pointer<duckdb_appender> appender,
  ) {
    return _duckdb_appender_destroy(
      appender,
    );
  }

  late final _duckdb_appender_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<duckdb_appender>)>>(
      'duckdb_appender_destroy');
  late final _duckdb_appender_destroy = _duckdb_appender_destroyPtr
      .asFunction<int Function(ffi.Pointer<duckdb_appender>)>();

  /// !
  /// A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.
  int duckdb_appender_begin_row(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_begin_row(
      appender,
    );
  }

  late final _duckdb_appender_begin_rowPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_appender)>>(
          'duckdb_appender_begin_row');
  late final _duckdb_appender_begin_row =
      _duckdb_appender_begin_rowPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Finish the current row of appends. After end_row is called, the next row can be appended.
  ///
  /// appender: The appender.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_appender_end_row(
    duckdb_appender appender,
  ) {
    return _duckdb_appender_end_row(
      appender,
    );
  }

  late final _duckdb_appender_end_rowPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_appender)>>(
          'duckdb_appender_end_row');
  late final _duckdb_appender_end_row =
      _duckdb_appender_end_rowPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Append a bool value to the appender.
  int duckdb_append_bool(
    duckdb_appender appender,
    bool value,
  ) {
    return _duckdb_append_bool(
      appender,
      value,
    );
  }

  late final _duckdb_append_boolPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Bool)>>(
      'duckdb_append_bool');
  late final _duckdb_append_bool =
      _duckdb_append_boolPtr.asFunction<int Function(duckdb_appender, bool)>();

  /// !
  /// Append an int8_t value to the appender.
  int duckdb_append_int8(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_int8(
      appender,
      value,
    );
  }

  late final _duckdb_append_int8Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Int8)>>(
      'duckdb_append_int8');
  late final _duckdb_append_int8 =
      _duckdb_append_int8Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append an int16_t value to the appender.
  int duckdb_append_int16(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_int16(
      appender,
      value,
    );
  }

  late final _duckdb_append_int16Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Int16)>>(
      'duckdb_append_int16');
  late final _duckdb_append_int16 =
      _duckdb_append_int16Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append an int32_t value to the appender.
  int duckdb_append_int32(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_int32(
      appender,
      value,
    );
  }

  late final _duckdb_append_int32Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Int32)>>(
      'duckdb_append_int32');
  late final _duckdb_append_int32 =
      _duckdb_append_int32Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append an int64_t value to the appender.
  int duckdb_append_int64(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_int64(
      appender,
      value,
    );
  }

  late final _duckdb_append_int64Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Int64)>>(
      'duckdb_append_int64');
  late final _duckdb_append_int64 =
      _duckdb_append_int64Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a duckdb_hugeint value to the appender.
  int duckdb_append_hugeint(
    duckdb_appender appender,
    duckdb_hugeint value,
  ) {
    return _duckdb_append_hugeint(
      appender,
      value,
    );
  }

  late final _duckdb_append_hugeintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_appender, duckdb_hugeint)>>('duckdb_append_hugeint');
  late final _duckdb_append_hugeint = _duckdb_append_hugeintPtr
      .asFunction<int Function(duckdb_appender, duckdb_hugeint)>();

  /// !
  /// Append a uint8_t value to the appender.
  int duckdb_append_uint8(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_uint8(
      appender,
      value,
    );
  }

  late final _duckdb_append_uint8Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Uint8)>>(
      'duckdb_append_uint8');
  late final _duckdb_append_uint8 =
      _duckdb_append_uint8Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a uint16_t value to the appender.
  int duckdb_append_uint16(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_uint16(
      appender,
      value,
    );
  }

  late final _duckdb_append_uint16Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Uint16)>>(
      'duckdb_append_uint16');
  late final _duckdb_append_uint16 =
      _duckdb_append_uint16Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a uint32_t value to the appender.
  int duckdb_append_uint32(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_uint32(
      appender,
      value,
    );
  }

  late final _duckdb_append_uint32Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Uint32)>>(
      'duckdb_append_uint32');
  late final _duckdb_append_uint32 =
      _duckdb_append_uint32Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a uint64_t value to the appender.
  int duckdb_append_uint64(
    duckdb_appender appender,
    int value,
  ) {
    return _duckdb_append_uint64(
      appender,
      value,
    );
  }

  late final _duckdb_append_uint64Ptr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Uint64)>>(
      'duckdb_append_uint64');
  late final _duckdb_append_uint64 =
      _duckdb_append_uint64Ptr.asFunction<int Function(duckdb_appender, int)>();

  /// !
  /// Append a float value to the appender.
  int duckdb_append_float(
    duckdb_appender appender,
    double value,
  ) {
    return _duckdb_append_float(
      appender,
      value,
    );
  }

  late final _duckdb_append_floatPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Float)>>(
      'duckdb_append_float');
  late final _duckdb_append_float = _duckdb_append_floatPtr
      .asFunction<int Function(duckdb_appender, double)>();

  /// !
  /// Append a double value to the appender.
  int duckdb_append_double(
    duckdb_appender appender,
    double value,
  ) {
    return _duckdb_append_double(
      appender,
      value,
    );
  }

  late final _duckdb_append_doublePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, ffi.Double)>>(
      'duckdb_append_double');
  late final _duckdb_append_double = _duckdb_append_doublePtr
      .asFunction<int Function(duckdb_appender, double)>();

  /// !
  /// Append a duckdb_date value to the appender.
  int duckdb_append_date(
    duckdb_appender appender,
    duckdb_date value,
  ) {
    return _duckdb_append_date(
      appender,
      value,
    );
  }

  late final _duckdb_append_datePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, duckdb_date)>>(
      'duckdb_append_date');
  late final _duckdb_append_date = _duckdb_append_datePtr
      .asFunction<int Function(duckdb_appender, duckdb_date)>();

  /// !
  /// Append a duckdb_time value to the appender.
  int duckdb_append_time(
    duckdb_appender appender,
    duckdb_time value,
  ) {
    return _duckdb_append_time(
      appender,
      value,
    );
  }

  late final _duckdb_append_timePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(duckdb_appender, duckdb_time)>>(
      'duckdb_append_time');
  late final _duckdb_append_time = _duckdb_append_timePtr
      .asFunction<int Function(duckdb_appender, duckdb_time)>();

  /// !
  /// Append a duckdb_timestamp value to the appender.
  int duckdb_append_timestamp(
    duckdb_appender appender,
    duckdb_timestamp value,
  ) {
    return _duckdb_append_timestamp(
      appender,
      value,
    );
  }

  late final _duckdb_append_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_appender, duckdb_timestamp)>>('duckdb_append_timestamp');
  late final _duckdb_append_timestamp = _duckdb_append_timestampPtr
      .asFunction<int Function(duckdb_appender, duckdb_timestamp)>();

  /// !
  /// Append a duckdb_interval value to the appender.
  int duckdb_append_interval(
    duckdb_appender appender,
    duckdb_interval value,
  ) {
    return _duckdb_append_interval(
      appender,
      value,
    );
  }

  late final _duckdb_append_intervalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_appender, duckdb_interval)>>('duckdb_append_interval');
  late final _duckdb_append_interval = _duckdb_append_intervalPtr
      .asFunction<int Function(duckdb_appender, duckdb_interval)>();

  /// !
  /// Append a varchar value to the appender.
  int duckdb_append_varchar(
    duckdb_appender appender,
    ffi.Pointer<ffi.Char> val,
  ) {
    return _duckdb_append_varchar(
      appender,
      val,
    );
  }

  late final _duckdb_append_varcharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_appender,
              ffi.Pointer<ffi.Char>)>>('duckdb_append_varchar');
  late final _duckdb_append_varchar = _duckdb_append_varcharPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Char>)>();

  /// !
  /// Append a varchar value to the appender.
  int duckdb_append_varchar_length(
    duckdb_appender appender,
    ffi.Pointer<ffi.Char> val,
    int length,
  ) {
    return _duckdb_append_varchar_length(
      appender,
      val,
      length,
    );
  }

  late final _duckdb_append_varchar_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_appender, ffi.Pointer<ffi.Char>,
              idx_t)>>('duckdb_append_varchar_length');
  late final _duckdb_append_varchar_length = _duckdb_append_varchar_lengthPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Char>, int)>();

  /// !
  /// Append a blob value to the appender.
  int duckdb_append_blob(
    duckdb_appender appender,
    ffi.Pointer<ffi.Void> data,
    int length,
  ) {
    return _duckdb_append_blob(
      appender,
      data,
      length,
    );
  }

  late final _duckdb_append_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_appender, ffi.Pointer<ffi.Void>,
              idx_t)>>('duckdb_append_blob');
  late final _duckdb_append_blob = _duckdb_append_blobPtr
      .asFunction<int Function(duckdb_appender, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// Append a NULL value to the appender (of any type).
  int duckdb_append_null(
    duckdb_appender appender,
  ) {
    return _duckdb_append_null(
      appender,
    );
  }

  late final _duckdb_append_nullPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(duckdb_appender)>>(
          'duckdb_append_null');
  late final _duckdb_append_null =
      _duckdb_append_nullPtr.asFunction<int Function(duckdb_appender)>();

  /// !
  /// Appends a pre-filled data chunk to the specified appender.
  ///
  /// The types of the data chunk must exactly match the types of the table, no casting is performed.
  /// If the types do not match or the appender is in an invalid state, DuckDBError is returned.
  /// If the append is successful, DuckDBSuccess is returned.
  ///
  /// appender: The appender to append to.
  /// chunk: The data chunk to append.
  /// returns: The return state.
  int duckdb_append_data_chunk(
    duckdb_appender appender,
    duckdb_data_chunk chunk,
  ) {
    return _duckdb_append_data_chunk(
      appender,
      chunk,
    );
  }

  late final _duckdb_append_data_chunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              duckdb_appender, duckdb_data_chunk)>>('duckdb_append_data_chunk');
  late final _duckdb_append_data_chunk = _duckdb_append_data_chunkPtr
      .asFunction<int Function(duckdb_appender, duckdb_data_chunk)>();

  /// ===--------------------------------------------------------------------===//
  /// Arrow Interface
  /// ===--------------------------------------------------------------------===//
  /// /*!
  /// Executes a SQL query within a connection and stores the full (materialized) result in an arrow structure.
  /// If the query fails to execute, DuckDBError is returned and the error message can be retrieved by calling
  /// `duckdb_query_arrow_error`.
  ///
  /// Note that after running `duckdb_query_arrow`, `duckdb_destroy_arrow` must be called on the result object even if the
  /// query fails, otherwise the error stored within the result will not be freed correctly.
  ///
  /// * connection: The connection to perform the query in.
  /// * query: The SQL query to run.
  /// * out_result: The query result.
  /// * returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  /// */
  int duckdb_query_arrow(
    duckdb_connection connection,
    ffi.Pointer<ffi.Char> query,
    ffi.Pointer<duckdb_arrow> out_result,
  ) {
    return _duckdb_query_arrow(
      connection,
      query,
      out_result,
    );
  }

  late final _duckdb_query_arrowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_connection, ffi.Pointer<ffi.Char>,
              ffi.Pointer<duckdb_arrow>)>>('duckdb_query_arrow');
  late final _duckdb_query_arrow = _duckdb_query_arrowPtr.asFunction<
      int Function(duckdb_connection, ffi.Pointer<ffi.Char>,
          ffi.Pointer<duckdb_arrow>)>();

  /// !
  /// Fetch the internal arrow schema from the arrow result.
  ///
  /// result: The result to fetch the schema from.
  /// out_schema: The output schema.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_query_arrow_schema(
    duckdb_arrow result,
    ffi.Pointer<duckdb_arrow_schema> out_schema,
  ) {
    return _duckdb_query_arrow_schema(
      result,
      out_schema,
    );
  }

  late final _duckdb_query_arrow_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_arrow,
              ffi.Pointer<duckdb_arrow_schema>)>>('duckdb_query_arrow_schema');
  late final _duckdb_query_arrow_schema =
      _duckdb_query_arrow_schemaPtr.asFunction<
          int Function(duckdb_arrow, ffi.Pointer<duckdb_arrow_schema>)>();

  /// !
  /// Fetch the internal arrow schema from the prepared statement.
  ///
  /// result: The prepared statement to fetch the schema from.
  /// out_schema: The output schema.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_prepared_arrow_schema(
    duckdb_prepared_statement prepared,
    ffi.Pointer<duckdb_arrow_schema> out_schema,
  ) {
    return _duckdb_prepared_arrow_schema(
      prepared,
      out_schema,
    );
  }

  late final _duckdb_prepared_arrow_schemaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(duckdb_prepared_statement,
                  ffi.Pointer<duckdb_arrow_schema>)>>(
      'duckdb_prepared_arrow_schema');
  late final _duckdb_prepared_arrow_schema =
      _duckdb_prepared_arrow_schemaPtr.asFunction<
          int Function(
              duckdb_prepared_statement, ffi.Pointer<duckdb_arrow_schema>)>();

  /// !
  /// Fetch an internal arrow array from the arrow result.
  ///
  /// This function can be called multiple time to get next chunks, which will free the previous out_array.
  /// So consume the out_array before calling this function again.
  ///
  /// result: The result to fetch the array from.
  /// out_array: The output array.
  /// returns: `DuckDBSuccess` on success or `DuckDBError` on failure.
  int duckdb_query_arrow_array(
    duckdb_arrow result,
    ffi.Pointer<duckdb_arrow_array> out_array,
  ) {
    return _duckdb_query_arrow_array(
      result,
      out_array,
    );
  }

  late final _duckdb_query_arrow_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(duckdb_arrow,
              ffi.Pointer<duckdb_arrow_array>)>>('duckdb_query_arrow_array');
  late final _duckdb_query_arrow_array =
      _duckdb_query_arrow_arrayPtr.asFunction<
          int Function(duckdb_arrow, ffi.Pointer<duckdb_arrow_array>)>();

  /// !
  /// Returns the number of columns present in a the arrow result object.
  ///
  /// result: The result object.
  /// returns: The number of columns present in the result object.
  int duckdb_arrow_column_count(
    duckdb_arrow result,
  ) {
    return _duckdb_arrow_column_count(
      result,
    );
  }

  late final _duckdb_arrow_column_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_arrow)>>(
          'duckdb_arrow_column_count');
  late final _duckdb_arrow_column_count =
      _duckdb_arrow_column_countPtr.asFunction<int Function(duckdb_arrow)>();

  /// !
  /// Returns the number of rows present in a the arrow result object.
  ///
  /// result: The result object.
  /// returns: The number of rows present in the result object.
  int duckdb_arrow_row_count(
    duckdb_arrow result,
  ) {
    return _duckdb_arrow_row_count(
      result,
    );
  }

  late final _duckdb_arrow_row_countPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_arrow)>>(
          'duckdb_arrow_row_count');
  late final _duckdb_arrow_row_count =
      _duckdb_arrow_row_countPtr.asFunction<int Function(duckdb_arrow)>();

  /// !
  /// Returns the number of rows changed by the query stored in the arrow result. This is relevant only for
  /// INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.
  ///
  /// result: The result object.
  /// returns: The number of rows changed.
  int duckdb_arrow_rows_changed(
    duckdb_arrow result,
  ) {
    return _duckdb_arrow_rows_changed(
      result,
    );
  }

  late final _duckdb_arrow_rows_changedPtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_arrow)>>(
          'duckdb_arrow_rows_changed');
  late final _duckdb_arrow_rows_changed =
      _duckdb_arrow_rows_changedPtr.asFunction<int Function(duckdb_arrow)>();

  /// !
  /// Returns the error message contained within the result. The error is only set if `duckdb_query_arrow` returns
  /// `DuckDBError`.
  ///
  /// The error message should not be freed. It will be de-allocated when `duckdb_destroy_arrow` is called.
  ///
  /// result: The result object to fetch the nullmask from.
  /// returns: The error of the result.
  ffi.Pointer<ffi.Char> duckdb_query_arrow_error(
    duckdb_arrow result,
  ) {
    return _duckdb_query_arrow_error(
      result,
    );
  }

  late final _duckdb_query_arrow_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(duckdb_arrow)>>(
          'duckdb_query_arrow_error');
  late final _duckdb_query_arrow_error = _duckdb_query_arrow_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(duckdb_arrow)>();

  /// !
  /// Closes the result and de-allocates all memory allocated for the arrow result.
  ///
  /// result: The result to destroy.
  void duckdb_destroy_arrow(
    ffi.Pointer<duckdb_arrow> result,
  ) {
    return _duckdb_destroy_arrow(
      result,
    );
  }

  late final _duckdb_destroy_arrowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<duckdb_arrow>)>>(
          'duckdb_destroy_arrow');
  late final _duckdb_destroy_arrow = _duckdb_destroy_arrowPtr
      .asFunction<void Function(ffi.Pointer<duckdb_arrow>)>();

  /// !
  /// Execute DuckDB tasks on this thread.
  ///
  /// Will return after `max_tasks` have been executed, or if there are no more tasks present.
  ///
  /// database: The database object to execute tasks for
  /// max_tasks: The maximum amount of tasks to execute
  void duckdb_execute_tasks(
    duckdb_database database,
    int max_tasks,
  ) {
    return _duckdb_execute_tasks(
      database,
      max_tasks,
    );
  }

  late final _duckdb_execute_tasksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_database, idx_t)>>(
          'duckdb_execute_tasks');
  late final _duckdb_execute_tasks = _duckdb_execute_tasksPtr
      .asFunction<void Function(duckdb_database, int)>();

  /// !
  /// Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until
  /// duckdb_finish_execution is called on the state.
  ///
  /// duckdb_destroy_state should be called on the result in order to free memory.
  ///
  /// database: The database object to create the task state for
  /// returns: The task state that can be used with duckdb_execute_tasks_state.
  duckdb_task_state duckdb_create_task_state(
    duckdb_database database,
  ) {
    return _duckdb_create_task_state(
      database,
    );
  }

  late final _duckdb_create_task_statePtr =
      _lookup<ffi.NativeFunction<duckdb_task_state Function(duckdb_database)>>(
          'duckdb_create_task_state');
  late final _duckdb_create_task_state = _duckdb_create_task_statePtr
      .asFunction<duckdb_task_state Function(duckdb_database)>();

  /// !
  /// Execute DuckDB tasks on this thread.
  ///
  /// The thread will keep on executing tasks forever, until duckdb_finish_execution is called on the state.
  /// Multiple threads can share the same duckdb_task_state.
  ///
  /// state: The task state of the executor
  void duckdb_execute_tasks_state(
    duckdb_task_state state,
  ) {
    return _duckdb_execute_tasks_state(
      state,
    );
  }

  late final _duckdb_execute_tasks_statePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_task_state)>>(
          'duckdb_execute_tasks_state');
  late final _duckdb_execute_tasks_state = _duckdb_execute_tasks_statePtr
      .asFunction<void Function(duckdb_task_state)>();

  /// !
  /// Execute DuckDB tasks on this thread.
  ///
  /// The thread will keep on executing tasks until either duckdb_finish_execution is called on the state,
  /// max_tasks tasks have been executed or there are no more tasks to be executed.
  ///
  /// Multiple threads can share the same duckdb_task_state.
  ///
  /// state: The task state of the executor
  /// max_tasks: The maximum amount of tasks to execute
  /// returns: The amount of tasks that have actually been executed
  int duckdb_execute_n_tasks_state(
    duckdb_task_state state,
    int max_tasks,
  ) {
    return _duckdb_execute_n_tasks_state(
      state,
      max_tasks,
    );
  }

  late final _duckdb_execute_n_tasks_statePtr =
      _lookup<ffi.NativeFunction<idx_t Function(duckdb_task_state, idx_t)>>(
          'duckdb_execute_n_tasks_state');
  late final _duckdb_execute_n_tasks_state = _duckdb_execute_n_tasks_statePtr
      .asFunction<int Function(duckdb_task_state, int)>();

  /// !
  /// Finish execution on a specific task.
  ///
  /// state: The task state to finish execution
  void duckdb_finish_execution(
    duckdb_task_state state,
  ) {
    return _duckdb_finish_execution(
      state,
    );
  }

  late final _duckdb_finish_executionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_task_state)>>(
          'duckdb_finish_execution');
  late final _duckdb_finish_execution = _duckdb_finish_executionPtr
      .asFunction<void Function(duckdb_task_state)>();

  /// !
  /// Check if the provided duckdb_task_state has finished execution
  ///
  /// state: The task state to inspect
  /// returns: Whether or not duckdb_finish_execution has been called on the task state
  bool duckdb_task_state_is_finished(
    duckdb_task_state state,
  ) {
    return _duckdb_task_state_is_finished(
      state,
    );
  }

  late final _duckdb_task_state_is_finishedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_task_state)>>(
          'duckdb_task_state_is_finished');
  late final _duckdb_task_state_is_finished = _duckdb_task_state_is_finishedPtr
      .asFunction<bool Function(duckdb_task_state)>();

  /// !
  /// Destroys the task state returned from duckdb_create_task_state.
  ///
  /// Note that this should not be called while there is an active duckdb_execute_tasks_state running
  /// on the task state.
  ///
  /// state: The task state to clean up
  void duckdb_destroy_task_state(
    duckdb_task_state state,
  ) {
    return _duckdb_destroy_task_state(
      state,
    );
  }

  late final _duckdb_destroy_task_statePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(duckdb_task_state)>>(
          'duckdb_destroy_task_state');
  late final _duckdb_destroy_task_state = _duckdb_destroy_task_statePtr
      .asFunction<void Function(duckdb_task_state)>();

  /// !
  /// Returns true if execution of the current query is finished.
  ///
  /// con: The connection on which to check
  bool duckdb_execution_is_finished(
    duckdb_connection con,
  ) {
    return _duckdb_execution_is_finished(
      con,
    );
  }

  late final _duckdb_execution_is_finishedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(duckdb_connection)>>(
          'duckdb_execution_is_finished');
  late final _duckdb_execution_is_finished = _duckdb_execution_is_finishedPtr
      .asFunction<bool Function(duckdb_connection)>();

  /// !
  /// Fetches a data chunk from the (streaming) duckdb_result. This function should be called repeatedly until the result is
  /// exhausted.
  ///
  /// The result must be destroyed with `duckdb_destroy_data_chunk`.
  ///
  /// This function can only be used on duckdb_results created with 'duckdb_pending_prepared_streaming'
  ///
  /// If this function is used, none of the other result functions can be used and vice versa (i.e. this function cannot be
  /// mixed with the legacy result functions or the materialized result functions).
  ///
  /// It is not known beforehand how many chunks will be returned by this result.
  ///
  /// result: The result object to fetch the data chunk from.
  /// returns: The resulting data chunk. Returns `NULL` if the result has an error.
  duckdb_data_chunk duckdb_stream_fetch_chunk(
    duckdb_result result,
  ) {
    return _duckdb_stream_fetch_chunk(
      result,
    );
  }

  late final _duckdb_stream_fetch_chunkPtr =
      _lookup<ffi.NativeFunction<duckdb_data_chunk Function(duckdb_result)>>(
          'duckdb_stream_fetch_chunk');
  late final _duckdb_stream_fetch_chunk = _duckdb_stream_fetch_chunkPtr
      .asFunction<duckdb_data_chunk Function(duckdb_result)>();
}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// [XSI] The type idtype_t shall be defined as an enumeration type whose
/// possible values shall include at least P_ALL, P_PID, and P_PGID.
abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

final class __darwin_arm_exception_state extends ffi.Struct {
  /// number of arm exception taken
  @__uint32_t()
  external int __exception;

  /// Fault status
  @__uint32_t()
  external int __fsr;

  /// Virtual Fault Address
  @__uint32_t()
  external int __far;
}

typedef __uint32_t = ffi.UnsignedInt;

final class __darwin_arm_exception_state64 extends ffi.Struct {
  /// Virtual Fault Address
  @__uint64_t()
  external int __far;

  /// Exception syndrome
  @__uint32_t()
  external int __esr;

  /// number of arm exception taken
  @__uint32_t()
  external int __exception;
}

typedef __uint64_t = ffi.UnsignedLongLong;

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  /// Stack pointer r13
  @__uint32_t()
  external int __sp;

  /// Link register r14
  @__uint32_t()
  external int __lr;

  /// Program counter r15
  @__uint32_t()
  external int __pc;

  /// Current program status register
  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  /// Frame pointer x29
  @__uint64_t()
  external int __fp;

  /// Link register x30
  @__uint64_t()
  external int __lr;

  /// Stack pointer x31
  @__uint64_t()
  external int __sp;

  /// Program counter
  @__uint64_t()
  external int __pc;

  /// Current program status register
  @__uint32_t()
  external int __cpsr;

  /// Same size for 32-bit or 64-bit clients
  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  /// Bit 0 is SS (Hardware Single Step)
  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  /// Bit 0 is SS (Hardware Single Step)
  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

final class __darwin_sigaltstack extends ffi.Struct {
  /// signal stack base
  external ffi.Pointer<ffi.Void> ss_sp;

  /// signal stack length
  @__darwin_size_t()
  external int ss_size;

  /// SA_DISABLE and/or SA_ONSTACK
  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  /// signal mask used by this context
  @__darwin_sigset_t()
  external int uc_sigmask;

  /// stack used by this context
  external __darwin_sigaltstack uc_stack;

  /// pointer to resuming context
  external ffi.Pointer<__darwin_ucontext> uc_link;

  /// size of the machine context passed in
  @__darwin_size_t()
  external int uc_mcsize;

  /// pointer to machine specific context
  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef __darwin_sigset_t = __uint32_t;

final class sigval extends ffi.Union {
  /// Members as suggested by Annex C of POSIX 1003.1b.
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  /// Notification type
  @ffi.Int()
  external int sigev_notify;

  /// Signal number
  @ffi.Int()
  external int sigev_signo;

  /// Signal value
  external sigval sigev_value;

  /// Notification function
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  /// Notification attributes
  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

final class __siginfo extends ffi.Struct {
  /// signal number
  @ffi.Int()
  external int si_signo;

  /// errno association
  @ffi.Int()
  external int si_errno;

  /// signal code
  @ffi.Int()
  external int si_code;

  /// sending process
  @pid_t()
  external int si_pid;

  /// sender's ruid
  @uid_t()
  external int si_uid;

  /// exit value
  @ffi.Int()
  external int si_status;

  /// faulting instruction
  external ffi.Pointer<ffi.Void> si_addr;

  /// signal value
  external sigval si_value;

  /// band event for SIGPOLL
  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

/// union for signal handlers
final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

/// Signal vector template for Kernel user boundary
final class __sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;

/// Signal vector "template" used in sigaction call.
final class sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u1;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

/// 4.3 compatibility:
/// Signal vector "template" used in sigvec call.
final class sigvec extends ffi.Struct {
  /// signal handler
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  /// signal mask to apply
  @ffi.Int()
  external int sv_mask;

  /// see signal options below
  @ffi.Int()
  external int sv_flags;
}

/// Structure used in sigstack call.
final class sigstack extends ffi.Struct {
  /// signal stack pointer
  external ffi.Pointer<ffi.Char> ss_sp;

  /// current status
  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  /// seconds
  @__darwin_time_t()
  external int tv_sec;

  /// and microseconds
  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef __darwin_suseconds_t = __int32_t;

/// A structure representing an accounting of resource utilization.  The
/// address of an instance of this structure is the second parameter to
/// getrusage().
///
/// Note: All values other than ru_utime and ru_stime are implementaiton
/// defined and subject to change in a future release.  Their use
/// is discouraged for standards compliant programs.
final class rusage extends ffi.Struct {
  /// user time used (PL)
  external timeval ru_utime;

  /// system time used (PL)
  external timeval ru_stime;

  /// max resident set size (PL)
  @ffi.Long()
  external int ru_maxrss;

  /// integral shared memory size (NU)
  @ffi.Long()
  external int ru_ixrss;

  /// integral unshared data (NU)
  @ffi.Long()
  external int ru_idrss;

  /// integral unshared stack (NU)
  @ffi.Long()
  external int ru_isrss;

  /// page reclaims (NU)
  @ffi.Long()
  external int ru_minflt;

  /// page faults (NU)
  @ffi.Long()
  external int ru_majflt;

  /// swaps (NU)
  @ffi.Long()
  external int ru_nswap;

  /// block input operations (atomic)
  @ffi.Long()
  external int ru_inblock;

  /// block output operations (atomic)
  @ffi.Long()
  external int ru_oublock;

  /// messages sent (atomic)
  @ffi.Long()
  external int ru_msgsnd;

  /// messages received (atomic)
  @ffi.Long()
  external int ru_msgrcv;

  /// signals received (atomic)
  @ffi.Long()
  external int ru_nsignals;

  /// voluntary context switches (atomic)
  @ffi.Long()
  external int ru_nvcsw;

  /// involuntary "
  @ffi.Long()
  external int ru_nivcsw;
}

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

/// A structure representing a resource limit.  The address of an instance
/// of this structure is the second parameter to getrlimit()/setrlimit().
final class rlimit extends ffi.Struct {
  /// current (soft) limit
  @rlim_t()
  external int rlim_cur;

  /// maximum value for rlim_cur
  @rlim_t()
  external int rlim_max;
}

/// Resource limit type (low 63 bits, excluding the sign bit)
typedef rlim_t = __uint64_t;

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

typedef id_t = __darwin_id_t;
typedef __darwin_id_t = __uint32_t;

/// Functions for byte reversed loads.
@ffi.Packed(1)
final class _OSUnalignedU16 extends ffi.Struct {
  @ffi.Uint16()
  external int __val;
}

@ffi.Packed(1)
final class _OSUnalignedU32 extends ffi.Struct {
  @ffi.Uint32()
  external int __val;
}

@ffi.Packed(1)
final class _OSUnalignedU64 extends ffi.Struct {
  @ffi.Uint64()
  external int __val;
}

/// Deprecated:
/// Structure of the information in the status word returned by wait4.
/// If w_stopval==_WSTOPPED, then the second structure describes
/// the information returned, else the first.
final class wait extends ffi.Opaque {}

final class div_t extends ffi.Struct {
  /// quotient
  @ffi.Int()
  external int quot;

  /// remainder
  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  /// quotient
  @ffi.Long()
  external int quot;

  /// remainder
  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

/// <malloc/_malloc.h>
typedef malloc_type_id_t = ffi.UnsignedLongLong;

final class _malloc_zone_t extends ffi.Opaque {}

/// <malloc/malloc.h>
typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef __darwin_dev_t = __int32_t;
typedef mode_t = __darwin_mode_t;
typedef __darwin_mode_t = __uint16_t;
typedef __uint16_t = ffi.UnsignedShort;

abstract class DUCKDB_TYPE {
  static const int DUCKDB_TYPE_INVALID = 0;

  /// bool
  static const int DUCKDB_TYPE_BOOLEAN = 1;

  /// int8_t
  static const int DUCKDB_TYPE_TINYINT = 2;

  /// int16_t
  static const int DUCKDB_TYPE_SMALLINT = 3;

  /// int32_t
  static const int DUCKDB_TYPE_INTEGER = 4;

  /// int64_t
  static const int DUCKDB_TYPE_BIGINT = 5;

  /// uint8_t
  static const int DUCKDB_TYPE_UTINYINT = 6;

  /// uint16_t
  static const int DUCKDB_TYPE_USMALLINT = 7;

  /// uint32_t
  static const int DUCKDB_TYPE_UINTEGER = 8;

  /// uint64_t
  static const int DUCKDB_TYPE_UBIGINT = 9;

  /// float
  static const int DUCKDB_TYPE_FLOAT = 10;

  /// double
  static const int DUCKDB_TYPE_DOUBLE = 11;

  /// duckdb_timestamp, in microseconds
  static const int DUCKDB_TYPE_TIMESTAMP = 12;

  /// duckdb_date
  static const int DUCKDB_TYPE_DATE = 13;

  /// duckdb_time
  static const int DUCKDB_TYPE_TIME = 14;

  /// duckdb_interval
  static const int DUCKDB_TYPE_INTERVAL = 15;

  /// duckdb_hugeint
  static const int DUCKDB_TYPE_HUGEINT = 16;

  /// const char*
  static const int DUCKDB_TYPE_VARCHAR = 17;

  /// duckdb_blob
  static const int DUCKDB_TYPE_BLOB = 18;

  /// decimal
  static const int DUCKDB_TYPE_DECIMAL = 19;

  /// duckdb_timestamp, in seconds
  static const int DUCKDB_TYPE_TIMESTAMP_S = 20;

  /// duckdb_timestamp, in milliseconds
  static const int DUCKDB_TYPE_TIMESTAMP_MS = 21;

  /// duckdb_timestamp, in nanoseconds
  static const int DUCKDB_TYPE_TIMESTAMP_NS = 22;

  /// enum type, only useful as logical type
  static const int DUCKDB_TYPE_ENUM = 23;

  /// list type, only useful as logical type
  static const int DUCKDB_TYPE_LIST = 24;

  /// struct type, only useful as logical type
  static const int DUCKDB_TYPE_STRUCT = 25;

  /// map type, only useful as logical type
  static const int DUCKDB_TYPE_MAP = 26;

  /// duckdb_hugeint
  static const int DUCKDB_TYPE_UUID = 27;

  /// union type, only useful as logical type
  static const int DUCKDB_TYPE_UNION = 28;

  /// duckdb_bit
  static const int DUCKDB_TYPE_BIT = 29;
}

/// ! Days are stored as days since 1970-01-01
/// ! Use the duckdb_from_date/duckdb_to_date function to extract individual information
final class duckdb_date extends ffi.Struct {
  @ffi.Int32()
  external int days;
}

final class duckdb_date_struct extends ffi.Struct {
  @ffi.Int32()
  external int year;

  @ffi.Int8()
  external int month;

  @ffi.Int8()
  external int day;
}

/// ! Time is stored as microseconds since 00:00:00
/// ! Use the duckdb_from_time/duckdb_to_time function to extract individual information
final class duckdb_time extends ffi.Struct {
  @ffi.Int64()
  external int micros;
}

final class duckdb_time_struct extends ffi.Struct {
  @ffi.Int8()
  external int hour;

  @ffi.Int8()
  external int min;

  @ffi.Int8()
  external int sec;

  @ffi.Int32()
  external int micros;
}

/// ! Timestamps are stored as microseconds since 1970-01-01
/// ! Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
final class duckdb_timestamp extends ffi.Struct {
  @ffi.Int64()
  external int micros;
}

final class duckdb_timestamp_struct extends ffi.Struct {
  external duckdb_date_struct date;

  external duckdb_time_struct time;
}

final class duckdb_interval extends ffi.Struct {
  @ffi.Int32()
  external int months;

  @ffi.Int32()
  external int days;

  @ffi.Int64()
  external int micros;
}

/// ! Hugeints are composed in a (lower, upper) component
/// ! The value of the hugeint is upper * 2^64 + lower
/// ! For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
final class duckdb_hugeint extends ffi.Struct {
  @ffi.Uint64()
  external int lower;

  @ffi.Int64()
  external int upper;
}

final class duckdb_decimal extends ffi.Struct {
  @ffi.Uint8()
  external int width;

  @ffi.Uint8()
  external int scale;

  external duckdb_hugeint value;
}

final class duckdb_string extends ffi.Struct {
  external ffi.Pointer<ffi.Char> data;

  @idx_t()
  external int size;
}

/// ===--------------------------------------------------------------------===//
/// Type Information
/// ===--------------------------------------------------------------------===//
typedef idx_t = ffi.Uint64;

/// The internal data representation of a VARCHAR/BLOB column
final class duckdb_string_t extends ffi.Struct {
  external UnnamedUnion1 value;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct3 pointer;

  external UnnamedStruct4 inlined;
}

final class UnnamedStruct3 extends ffi.Struct {
  @ffi.Uint32()
  external int length;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> prefix;

  external ffi.Pointer<ffi.Char> ptr;
}

final class UnnamedStruct4 extends ffi.Struct {
  @ffi.Uint32()
  external int length;

  @ffi.Array.multi([12])
  external ffi.Array<ffi.Char> inlined;
}

final class duckdb_blob extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @idx_t()
  external int size;
}

final class duckdb_list_entry extends ffi.Struct {
  @ffi.Uint64()
  external int offset;

  @ffi.Uint64()
  external int length;
}

final class duckdb_column extends ffi.Struct {
  /// deprecated, use duckdb_column_data
  external ffi.Pointer<ffi.Void> __deprecated_data;

  /// deprecated, use duckdb_nullmask_data
  external ffi.Pointer<ffi.Bool> __deprecated_nullmask;

  /// deprecated, use duckdb_column_type
  @ffi.Int32()
  external int __deprecated_type;

  /// deprecated, use duckdb_column_name
  external ffi.Pointer<ffi.Char> __deprecated_name;

  external ffi.Pointer<ffi.Void> internal_data;
}

final class duckdb_result extends ffi.Struct {
  /// deprecated, use duckdb_column_count
  @idx_t()
  external int __deprecated_column_count;

  /// deprecated, use duckdb_row_count
  @idx_t()
  external int __deprecated_row_count;

  /// deprecated, use duckdb_rows_changed
  @idx_t()
  external int __deprecated_rows_changed;

  /// deprecated, use duckdb_column_ family of functions
  external ffi.Pointer<duckdb_column> __deprecated_columns;

  /// deprecated, use duckdb_result_error
  external ffi.Pointer<ffi.Char> __deprecated_error_message;

  external ffi.Pointer<ffi.Void> internal_data;
}

final class _duckdb_database extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __db;
}

final class _duckdb_connection extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __conn;
}

final class _duckdb_prepared_statement extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __prep;
}

final class _duckdb_extracted_statements extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __extrac;
}

final class _duckdb_pending_result extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __pend;
}

final class _duckdb_appender extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __appn;
}

final class _duckdb_arrow extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __arrw;
}

final class _duckdb_arrow_stream extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __arrwstr;
}

final class _duckdb_config extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __cnfg;
}

final class _duckdb_arrow_schema extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __arrs;
}

final class _duckdb_arrow_array extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __arra;
}

final class _duckdb_logical_type extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __lglt;
}

final class _duckdb_data_chunk extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __dtck;
}

final class _duckdb_vector extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __vctr;
}

final class _duckdb_value extends ffi.Struct {
  external ffi.Pointer<ffi.Void> __val;
}

abstract class duckdb_state {
  static const int DuckDBSuccess = 0;
  static const int DuckDBError = 1;
}

abstract class duckdb_pending_state {
  static const int DUCKDB_PENDING_RESULT_READY = 0;
  static const int DUCKDB_PENDING_RESULT_NOT_READY = 1;
  static const int DUCKDB_PENDING_ERROR = 2;
  static const int DUCKDB_PENDING_NO_TASKS_AVAILABLE = 3;
}

typedef duckdb_database = ffi.Pointer<_duckdb_database>;
typedef duckdb_config = ffi.Pointer<_duckdb_config>;
typedef duckdb_connection = ffi.Pointer<_duckdb_connection>;
typedef duckdb_logical_type = ffi.Pointer<_duckdb_logical_type>;
typedef duckdb_data_chunk = ffi.Pointer<_duckdb_data_chunk>;
typedef duckdb_prepared_statement = ffi.Pointer<_duckdb_prepared_statement>;
typedef duckdb_value = ffi.Pointer<_duckdb_value>;
typedef duckdb_arrow = ffi.Pointer<_duckdb_arrow>;
typedef duckdb_arrow_stream = ffi.Pointer<_duckdb_arrow_stream>;
typedef duckdb_arrow_schema = ffi.Pointer<_duckdb_arrow_schema>;
typedef duckdb_arrow_array = ffi.Pointer<_duckdb_arrow_array>;
typedef duckdb_extracted_statements = ffi.Pointer<_duckdb_extracted_statements>;
typedef duckdb_pending_result = ffi.Pointer<_duckdb_pending_result>;
typedef duckdb_vector = ffi.Pointer<_duckdb_vector>;

/// ===--------------------------------------------------------------------===//
/// Table Functions
/// ===--------------------------------------------------------------------===//
typedef duckdb_table_function = ffi.Pointer<ffi.Void>;
typedef duckdb_delete_callback_t
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef duckdb_table_function_bind_t
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(duckdb_bind_info)>>;
typedef duckdb_bind_info = ffi.Pointer<ffi.Void>;
typedef duckdb_table_function_init_t
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(duckdb_init_info)>>;
typedef duckdb_init_info = ffi.Pointer<ffi.Void>;
typedef duckdb_table_function_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(duckdb_function_info, duckdb_data_chunk)>>;
typedef duckdb_function_info = ffi.Pointer<ffi.Void>;
typedef duckdb_replacement_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(duckdb_replacement_scan_info, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// ===--------------------------------------------------------------------===//
/// Replacement Scans
/// ===--------------------------------------------------------------------===//
typedef duckdb_replacement_scan_info = ffi.Pointer<ffi.Void>;
typedef duckdb_appender = ffi.Pointer<_duckdb_appender>;

/// ===--------------------------------------------------------------------===//
/// Threading Information
/// ===--------------------------------------------------------------------===//
typedef duckdb_task_state = ffi.Pointer<ffi.Void>;

const int DUCKDB_API_0_3_1 = 1;

const int DUCKDB_API_0_3_2 = 2;

const int DUCKDB_API_LATEST = 2;

const int DUCKDB_API_VERSION = 2;

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int USER_ADDR_NULL = 0;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_XROS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_14_0 = 140000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_17_0 = 170000;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_10_0 = 100000;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_17_0 = 170000;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_8_0 = 80000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_23_0 = 230000;

const int __XROS_1_0 = 10000;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_14_0 = 140000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 140000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 140000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int NULL = 0;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;
